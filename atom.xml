<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geekaholic</title>
  
  <subtitle>编程在于折腾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.geekaholic.cn/"/>
  <updated>2019-09-26T05:21:46.907Z</updated>
  <id>http://blog.geekaholic.cn/</id>
  
  <author>
    <name>GeekaholicLin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Map 与 FlatMap 的对比</title>
    <link href="http://blog.geekaholic.cn/2017/09/27/%5B%E8%AF%91%5Dmap-vs-flatmap/"/>
    <id>http://blog.geekaholic.cn/2017/09/27/[译]map-vs-flatmap/</id>
    <published>2017-09-27T17:22:05.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<p title="This blog discusses difference between Map and FlatMap in RxJS.">这篇博客主要讨论RxJS中Map和FlatMap的区别。</p><p title="Anyone who has worked upon&#x2F;read about RXJS must be aware about various operators that this library includes, some of them are:">阅读或在工作使用<strong>RxJS</strong>的人一定会遇到RxJS中各式各样的操作符(operators)。包括但不限于：</p><ol style="list-style-type: decimal"><li title="0f - It simply converts a list of arguments into an Observable sequence."><strong>of</strong> - 该操作符将参数列表简单地转换为<strong>Observable</strong>序列</li><li title="from - Creates an Observable sequence from an array or an object that can be iterated."><strong>from</strong> - 从一个数组或者可迭代的对象中创建<strong>Observable</strong>序列。</li><li title="map - Transforms each element of the Observable sequence. Can be considered similar to map function of Array."><strong>map</strong> - 转换<strong>Observable</strong>序列中的每一个元素。可以简单地将该方法比作Array实例的<strong>map</strong>方法。</li><li title="subscribe - This operator is basically the connecting point between an Observer and Observable. An Observer receives item&#x2F;error&#x2F;completion notification from Observable using the subscribe operator. A cold observable would start emitting value only when an observer subscribes to it."><strong>subscribe</strong> - 这个操作符主要是<strong>Observer</strong>和<strong>Observable</strong>两者的连接点</li></ol><p title="The above ones are like most commonly used and you would get to know many new ones.">上面这些是最常用的，你可以知道更多新的操作符。</p><p title="Well, I encountered a situation where I had Observable of Observables and I wanted a single stream out of them and to solve this I got introduced to another interesting operator:">我之前遇到过一种使用<strong>Observables</strong>中的<strong>Observable</strong>(嵌套Observable)的情景，我想要获取单流输出。为了解决这个问题，接下来介绍另外的有趣操作符。</p><p title="flatMap - It basically merges an observable sequence of observable sequences into a single observable sequence."><strong>flatMap</strong> - 它主要将observable序列中的observable序列合并成单个observable序列。</p><p title="So, let’s take a sample snippet to see how the it works. We have an array of visitors as given below:">所以，让我们来看看一段代码，看其是如何工作的。我们有一个访问者数组，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> visitors = [</span><br><span class="line">    <span class="string">"Namita"</span>,</span><br><span class="line">    <span class="string">"Amit"</span>,</span><br><span class="line">    <span class="string">"Rohit"</span>,</span><br><span class="line">    <span class="string">"Neetika"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p title="Now, we want this array to be converted into an Observable sequence, so it can be done something like:">现在，我想要这个数组被转换为一个<strong>Observable</strong>序列，所以它可以像下面一样解决：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = Rx.Observable.from(visitors)</span><br><span class="line">    .map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="string">'Hello '</span> + x);</span><br></pre></td></tr></table></figure><p title="We will now have to subscribe to this sequence:">让我们来订阅这个序列：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">source.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">document</span>.getElementById(<span class="string">'flatMap'</span>).innerText += x + <span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure><p title="And view would look like this:">视图将会如下所示：</p><div class="figure"><img src="https://raw.githubusercontent.com/NamitaMalik/Map-vs-FlatMap/master/assets/map-flatMap.png" alt="map-flatMap.png"><p class="caption">map-flatMap.png</p></div><p title="But what we wanted to see was how to work with observable of observable sequence, so for that let’s make some changes as given below:">但是我们想解决的是如何使<strong>observable序列中的observable</strong>能正确处理，所以我们给上述代码做点改变：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = Rx.Observable.from(visitors)</span><br><span class="line">    .map(<span class="function"><span class="params">x</span> =&gt;</span> Rx.Observable.of(<span class="string">'Hello '</span> + x));</span><br></pre></td></tr></table></figure><p title="… and our view would look something like this:">然而我们的视图将会如下面图片一样（不正确地显示）：</p><div class="figure"><img src="https://raw.githubusercontent.com/NamitaMalik/Map-vs-FlatMap/master/assets/Map-error.png" alt="Map-error.png"><p class="caption">Map-error.png</p></div><p title="So how to fix this up? Well, now we’ll have to use our flatMap operator as given below:">所以应该如何修复？ 那我们就要使用<strong>flatMap</strong>操作符了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = Rx.Observable.from(visitors)</span><br><span class="line">    .flatMap(<span class="function"><span class="params">x</span> =&gt;</span> Rx.Observable.of(<span class="string">'Hello '</span> + x));</span><br></pre></td></tr></table></figure><p title="and now one can simply subscribe to it as we were doing earlier and our view as per our expectations:">现在我们就可以像之前那样简单地订阅，即可得到我们期望的结果：</p><div class="figure"><img src="https://raw.githubusercontent.com/NamitaMalik/Map-vs-FlatMap/master/assets/map-flatMap.png" alt="map-flatMap.png"><p class="caption">map-flatMap.png</p></div><p title="So what’s the exact difference between map and flatMap:">所以，<strong>map</strong>和<strong>flatMap</strong>的区别是什么：</p><p title="map transforms items emitted by an Observable by applying a function to each item whereas flatmap:"><strong>map</strong>将方法应用于Observable发射(emit)出的items转换为单个元素的item，而<strong>flatmap</strong>是：</p><ol style="list-style-type: decimal"><li title="Applies a specified function to each emitted item and this function in turn returns an Observable for each item.">发射出的每一个值运用特定方法，该特定方法将每一个值处理为一个Observable(序列)并依次返回</li><li title="flatMap then merges all these sequences to make a new sequence.">flatMap然后将所有这些序列合并成一个新的单一序列。</li></ol><p title="So let’s make a small ASCII marbel to make our understanding more clear:">让我们来使用ASCII珠宝图梳理一下上述的区别，或许更加通熟易懂。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----Namita---Amit---Rohit---Neetika----- //Input Stream</span><br><span class="line">.map(x =&gt; &apos;Hello &apos; + x);</span><br><span class="line">---Hello Namita---Hello Amit---Hello Rohit---Hello Neetika--- //Map&apos;s function result</span><br><span class="line"></span><br><span class="line">----Namita---Amit---Rohit---Neetika----- //Input Stream</span><br><span class="line">.flatMap(x =&gt; Rx.Observable.of(&apos;Hello &apos; + x))</span><br><span class="line">--Hello Namita--     //transforming each input element into an Observable</span><br><span class="line">--Hello Amit--</span><br><span class="line">--Hello Rohit--</span><br><span class="line">--Hello Neetika--</span><br><span class="line">---Hello Namita---Hello Amit---Hello Rohit---Hello Neetika--- // Flatmap&apos;s final result</span><br></pre></td></tr></table></figure><p title="There is also another operator named as .mergeAll which we can use with map when we are in observable of observables situation instead of directly using flatMap. RxJS has numerous operators and hopefully this learning voyage will take us to each one of them.. till then happy learning!">当需要处理observables中的observable(嵌套)的情况的时候，也可以使用另外的操作符<strong>mergeAll</strong>，和<strong>map</strong>搭配使用。这与直接使用<strong>flatMap</strong>的效果是一样的。 RxJS有着大量的操作符，希望这次学习之旅能帮到我们每一个人…继续快乐地学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p title=&quot;This blog discusses difference between Map and FlatMap in RxJS.&quot;&gt;这篇博客主要讨论RxJS中Map和FlatMap的区别。&lt;/p&gt;
&lt;p title=&quot;Anyone who has worked 
      
    
    </summary>
    
      <category term="他山之石" scheme="http://blog.geekaholic.cn/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/Web/"/>
    
    
      <category term="JavaScript" scheme="http://blog.geekaholic.cn/tags/JavaScript/"/>
    
      <category term="RxJS" scheme="http://blog.geekaholic.cn/tags/RxJS/"/>
    
      <category term="Translation" scheme="http://blog.geekaholic.cn/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>【译】双语对照翻译测试文件</title>
    <link href="http://blog.geekaholic.cn/2017/08/10/%E5%8F%8C%E8%AF%AD%E5%AF%B9%E7%85%A7%E7%BF%BB%E8%AF%91%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6.ts/"/>
    <id>http://blog.geekaholic.cn/2017/08/10/双语对照翻译测试文件.ts/</id>
    <published>2017-08-10T10:10:10.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文件与《pandoc-markdown测试文件》大同小异，再加上一些比较特殊的情况，比如嵌套列表， 测试在<strong>pandoc-markdown</strong>下翻译的处理情况是否准确。但为了行文容易阅读，不再包含代码块，可以自行到<code>markdown</code>格式的文件查看。 【请忽略不准确的翻译，毕竟本文展示的是翻译的显示效果而不是内容~】</p></blockquote><h1 id="综述" title="Overview">综述</h1><h1 id="基本元素测试" title="Basic Elements Testing">基本元素测试</h1><p title="The purpose of this post is to help you make sure all of HTML elements can display properly. If you use CSS reset, don’t forget to redefine the style by yourself.">这篇博客的目的是为了帮助你确认你的HTML元素是否以合适的方式展示出来。如果你使用了CSS重置样式， 不要忘记重新自定义你的样式。</p><hr><h1 id="标题1" title="Heading 1">标题1</h1><h2 id="标题2" title="Heading 2">标题2</h2><h3 id="标题3" title="Heading 3">标题3</h3><h4 id="标题4" title="Heading 4">标题4</h4><h5 id="标题5" title="Heading 5">标题5</h5><h6 id="标题6" title="Heading 6">标题6</h6><hr><h2 id="段落" title="Paragraph">段落</h2><p title="Lorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis.Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi.Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.">不知道生成的文本怎么翻译，只认识<a href>测试链接</a> <strong>强调文本</strong>后面也是一串生成文本。 <em>斜体</em>后面也是一串生成文本。 <u>下划线文本</u>后面也是一串生成文本。 <del>删除效果的文字</del> 后面亦是如此。 那我就念两句诗？gou……zhi</p><p title="Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed erat diam, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.">这么长一段文字“Interdum et malesuada fames ac ante ipsum primis…”就只有一种样式，那就是行内代码。比如<code>Sed erat diam</code></p><blockquote><p title="Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.">引用文本应该不会有问题吧。短文本我也看不懂机器生成的。</p></blockquote><p title="Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat.Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.">好像“Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices.”并没有什么需要注意的。我在Webstorm里面将其折叠， 而没有空一行或者空两个空格，应该还是在用一个块级元素里面，不会生成多个标签吧？就不知道Github的兼容如何了。</p><h2 id="列表类型" title="List Types">列表类型</h2><h3 id="定义列表（dl）" title="Definition List (dl)">定义列表（dl）</h3><dl><dt title="Definition List Title">定义列表的标题</dt><dd title="This is a definition list division.">这是一个定义列表分区</dd></dl><h3 id="有序列表（ol）" title="Ordered List (ol)">有序列表（ol）</h3><ol style="list-style-type: decimal"><li title="List Item 1">有序列表item1</li><li title="List Item 2">有序列表item2</li><li title="List Item 3">有序列表item3</li></ol><h3 id="嵌套有序列表（nested ol）" title="Nested Ordered List (nested ol)">嵌套有序列表（nested ol）</h3><ol style="list-style-type: decimal"><li><p class="nested-list-title" title="Ordered List Item 1">有序列表Item 1</p><ol style="list-style-type: decimal"><li title="Shallow Nested Order List Item 1">浅嵌套有序列表Item 1.1</li><li title="Shallow Nested Order List Item 2。 Shallow Nested Order List Item 2。 Shallow Nested Order List Item 2。">因为出现三次过长而在编辑器折行的浅嵌套有序列表Item 1.2</li><li title="Shallow Nested Order List Item 3">浅嵌套有序列表Item 1.3</li></ol></li><li><p class="nested-list-title" title="Ordered List Item 2">有序列表Item 2</p><ol style="list-style-type: decimal"><li><p class="nested-list-title" title="Shallow Nested Order List Item 1">浅嵌套有序列表Item 2.1</p><ol style="list-style-type: decimal"><li title="Deep Nested Order List Item 1">深层次嵌套有序列表Item 2.1.1</li><li title="Deep Nested Order List Item 1">深层次嵌套有序列表Item 2.1.2</li><li title="Deep Nested Order List Item 1。 Deep Nested Order List Item 1。 Deep Nested Order List Item 1。">因为出现三次过长而在编辑器折行的深层次嵌套有序列表Item 2.1.3</li></ol></li><li title="Shallow Nested Order List Item 2">浅嵌套有序列表Item 2.2</li><li title="Shallow Nested Order List Item 3">浅嵌套有序列表Item 2.3</li></ol></li><li title="Normal Ordered List Item 3">有序列表Item 3</li></ol><h3 id="无序列表" title="Unordered List (ul)">无序列表</h3><ul><li title="List Item 1">无序列表 1</li><li title="List Item 2">无序列表 2</li><li title="List Item 3">无序列表 3</li></ul><h3 id="嵌套无序列表（nested ul）" title="Nested Unordered List (nested ul)">嵌套无序列表（nested ul）</h3><ul><li><p class="nested-list-title" title="Unordered List Item 1">无序列表Item 1</p><ul><li title="Shallow Nested Unordered List Item 1">浅嵌套无序列表Item 1.1</li><li title="Shallow Nested Unordered List Item 1。 Shallow Nested Unordered List Item 1。 Shallow Nested Unordered List Item 1。">因为出现三次过长而在编辑器折行的浅嵌套无序列表Item 1.2</li><li title="Shallow Nested Unordered List Item 3">浅嵌套无序列表Item 1.3</li></ul></li><li><p class="nested-list-title" title="Unordered List Item 2">无序列表Item 2</p><ul><li><p class="nested-list-title" title="Shallow Nested Unordered List Item 1">浅嵌套无序列表Item 2.1</p><ul><li title="Deep Nested Unordered List Item 1">深层次嵌套无序列表Item 2.1.1</li><li title="Deep Nested Unordered List Item 1">深层次嵌套无序列表Item 2.1.2</li><li title="Deep Nested Unordered List Item 1。 Deep Nested Unordered List Item 1。 Deep Nested Unordered List Item 1。">因为出现三次过长而在编辑器折行的深层次嵌套无序列表Item 2.1.3</li></ul></li><li title="Shallow Nested Unordered List Item 2">浅嵌套无序列表Item 2.2</li><li title="Shallow Nested Unordered List Item 3">浅嵌套无序列表Item 2.3</li></ul></li><li title="Normal Unordered List Item 3">无序列表Item 3</li></ul><h2 id="表格" title="Table">表格</h2><table style="width:8%;"><colgroup><col width="2%"><col width="2%"><col width="2%"></colgroup><thead><tr class="header"><th title="Table Header 1">表格标题1</th><th title="Table Header 2">表格标题2</th><th title="Table Header 3">表格标题3</th></tr></thead><tbody><tr class="odd"><td title="Division 1">表格体1.1</td><td title="Division 2">表格体1.2</td><td title="Division 3">表格体1.3</td></tr><tr class="even"><td title="Division 1">表格体2.1</td><td title="Division 2">表格体2.2</td><td title="Division 3">表格体2.3</td></tr><tr class="odd"><td title="Division 1">表格体3.1</td><td title="Division 2">表格体3.2</td><td title="Division 3">表格体3.3</td></tr></tbody></table><h2 id="杂项 - abbr, acronym, sub, sup等等" title="Misc Stuff - abbr, acronym, sub, sup, etc.">杂项 - abbr, acronym, sub, sup等等</h2><p title="Lorem superscript dolor subscript amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. cite. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. NBA Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.AVE">这里有一个上角标<sup>superscript</sup>，这里有一个下角标 <sub>subscript</sub>，当然还有你我看不懂的胡说八道。 这一句并没有什么特别之处，就有一个cite引用，不信你看~ <cite>cite</cite> 我真的好想把手放在键盘上胡乱地敲。因为并没有什么需要讲的，但我还是忍了，but I am angry。而下面的这一句NBA，是使用了“acronym”标签， 因为它已经有了title属性，那我们就直接翻译，不做处理。<acronym title="National Basketball Association">NBA</acronym>，当然特殊的还有“abbr” 这个缩写标签，也不做处理，Let it go，谁让它们在p标签下面呢. <abbr title="Avenue">AVE</abbr></p><h1 id="标签测试" title="Tags Testing">标签测试</h1><p title="This post is used for testing tag plugins. See docs for more info.">这一章节是用来测试Hexo自带的标签(tag)插件。更多详情请查看<a href="http://zespia.tw/hexo/docs/tag-plugins.html" target="_blank" rel="noopener">文档</a></p><h2 id="块级引用" title="Block Quote">块级引用</h2><h3 id="一般块级引用" title="Normal blockquote">一般块级引用</h3><blockquote><p title="Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.">真心无f**k可说，别总是想借用生成文本搞大新闻</p></blockquote><h3 id="引述自书本" title="Quote from a book">引述自书本</h3><blockquote title="Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.David LevithanWide Awake">为什么只有body部分呢？哦，对哦，人名一般也不需要翻译，nice~这句谚语翻译过来就是：独乐乐不如众乐乐？<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="引述自Twitter" title="Quote from Twitter">引述自Twitter</h3><blockquote title="NEW: DevDocs now comes with syntax highlighting. http:&#x2F;&#x2F;devdocs.io">震惊！！！DevDocs支持语法高亮！！详情点击 http://devdocs.io<footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="noopener">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="引述自网络中的文章" title="Quote from an article on the web">引述自网络中的文章</h3><blockquote title="Every interaction is both precious and an opportunity to delight.Seth GodinWelcome to Island Marketing">每次的互动都是宝贵的？（好low的翻译）<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="代码块" title="Code Block">代码块</h2><h3 id="普通代码块" title="Normal code block">普通代码块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure><h3 id="拥有标题的代码块" title="With caption">拥有标题的代码块</h3><figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="拥有标题和链接的代码块" title="With caption and URL">拥有标题和链接的代码块</h3><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h3 id="拥有高亮代码行的代码块" title="With marked lines">拥有高亮代码行的代码块</h3><p title="Line 1,7-8,10 should be marked with different color.">第1，7，8，10行应该被不同于背景色的颜色标记。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line marked"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line marked">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line marked">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(port, hostname, () =&gt; &#123;</span><br><span class="line marked">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p title="Note: Theme’s style should support .highlight.line.marked (recommend to use the selection or current line color).">注意：主题的样式应该支持<code>.highlight.line.marked</code>（建议使用选中颜色或者当前行的颜色）</p><h3 id="Gist">Gist</h3><script src="//gist.github.com/996818.js"></script><h3 id="jsFiddle">jsFiddle</h3><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" allowfullscreen></iframe><h2 id="醒目引文" title="Pullquote">醒目引文</h2><h3 id="左醒目引文" title="Left">左醒目引文</h3><blockquote class="pullquote left" title="Lorem ipsum dolor sit amet, consectetur adipiscing elit.">说好的左醒目引文，你就糊弄我？</blockquote><p title="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.">一串很长又没有意义的文字，我也可以啊。 ash多哈so防患未然斯蒂芬拉黑色调为urodhfasdf 阿大区物业QWDGUWQWAHEWOEFH阿萨德阿误认为而已发撒旦气温偶点告破i热土未全额uiqwyefiasdfwqeiuiowa三大队立即投入诶阿怒气未tv了关于i二阿桑的期望哦谷热他俩三等奖权威。 就问你怕不怕！！！我先去洗一下脸，键盘好脏。</p><h3 id="右醒目引文" title="Right">右醒目引文</h3><blockquote class="pullquote right" title="Lorem ipsum dolor sit amet, consectetur adipiscing elit.">一个糊弄我就算了，右边的你也来？</blockquote><p title="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.">一串很长又没有意义的文字，我也可以啊。 ash多哈so防患未然斯蒂芬拉黑色调为urodhfasdf 阿大区物业QWDGUWQWAHEWOEFH阿萨德阿误认为而已发撒旦气温偶点告破i热土未全额uiqwyefiasdfwqeiuiowa三大队立即投入诶阿怒气未tv了关于i二阿桑的期望哦谷热他俩三等奖权威。 就问你怕不怕！！！我先去洗一下脸，键盘好脏。 Ctrl+C，Ctrl+V就是那么简单~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文件与《pandoc-markdown测试文件》大同小异，再加上一些比较特殊的情况，比如嵌套列表， 测试在&lt;strong&gt;pandoc-markdown&lt;/strong&gt;下翻译的处理情况是否准确。但为了行文容易阅读，不再包含代码块，可以自行到&lt;c
      
    
    </summary>
    
      <category term="他山之石" scheme="http://blog.geekaholic.cn/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/Web/"/>
    
    
      <category term="Translation" scheme="http://blog.geekaholic.cn/tags/Translation/"/>
    
      <category term="Hexo" scheme="http://blog.geekaholic.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>从伪类和伪元素说起的知识点</title>
    <link href="http://blog.geekaholic.cn/2017/03/19/%E4%BB%8E%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E8%AF%B4%E8%B5%B7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://blog.geekaholic.cn/2017/03/19/从伪类和伪元素说起的知识点/</id>
    <published>2017-03-19T19:45:04.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<p>在YY的一轮面试之后，和工作室的小伙伴一起讨论了“CSS伪类和伪元素”(因为就有一个面试问题是问“遇到过哪些伪类和伪元素，使用的场景有哪些？”)，发现牵扯进来的边边角角还是挺多的，就用一篇文章来记录一下，如果有更多涉及两者的知识点，欢迎补充~</p><h2 id="伪类和伪元素的区别">伪类和伪元素的区别</h2><p>在刚开始学习前端的时候，我根本就没有注意到<strong>伪类</strong>和<strong>伪元素</strong>说的是两个不同的东西，毕竟都是<code>:xxx</code>来表示。在MDN查询<code>document.querySelectorAll()</code>的API时，跳转到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">伪元素</a></p><blockquote><p>就像 pseudo classes (伪类)一样…</p></blockquote><p>然后就意识到两者的不同，而且<code>document.querySelectorAll()</code>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll" target="_blank" rel="noopener">中文翻译</a>也搞混了，英文版本的是说<code>querySelectorAll()</code>的选择器语法不支持<code>伪元素</code>而不是<code>伪类</code>。以伪类中的<code>:target</code>为例子，可以正确返回结果，见下图所示，可见两者还是很容易混淆的。</p><div class="figure"><img src="http://old-image.geekaholic.cn/2017-03-20_161608_0001.jpg" alt=":target伪类"><p class="caption">:target伪类</p></div><p>(有一个小插曲，想吐槽一下MDN。在很久之前就发现了翻译页面的错误，那时也想着改正，但是MDN编辑语法什么的真是orz，后来就放弃了，因为学习成本还算挺高的。一直到写这篇文章的时候，又记起这件事，实在忍不住，改正了翻译，不到100个字，花了我半个多小时…)</p><p><strong>那么问题来了，如何区分两者？</strong></p><p>在<a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">一篇博客</a>中的一张图已经为我们归纳了两者，</p><div class="figure"><img src="http://old-image.geekaholic.cn/2017-03-20_161854_0002.jpg" alt="两者区别的归纳图"><p class="caption">两者区别的归纳图</p></div><p>但是这并不是正确的打开方式，这只是知其然不知其所以然。</p><p>让我们回归<strong>W3C规范</strong>看看，规范是怎么对<a href="https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#pseudo-elements" target="_blank" rel="noopener">伪元素</a>和<a href="https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#pseudo-classes" target="_blank" rel="noopener">伪类</a>进行定义的。</p><blockquote><p>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors. 简单翻译：伪类这个概念的引入，是为了允许(authors)对那些在文档树之外或无法使用简单css选择器表示的信息(ps:个人感觉“文档树之外的状态”和“css选择器表示的元素”会更贴切)进行选择获取</p></blockquote><blockquote><p>Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. 简单翻译：在文档语言规定之外，伪元素创建了一个关于文档树的抽象引用。比如，文档语言并未提供获取元素的第一个字或者第一行的机制。</p></blockquote><p>orz，差别在哪？</p><p>如果你想看看别人对两者的解读，可以看看<a href="http://stackoverflow.com/questions/8069973/what-is-the-difference-between-a-pseudo-class-and-a-pseudo-element-in-css#answer-11701951" target="_blank" rel="noopener">stackoverflow这个回答以及评论区的讨论</a></p><p><strong>按照我个人的理解：</strong><code>伪类</code>侧重描述(descript,not filter)以不同于简单选择器选择存在的元素(比如<code>:first-child</code>)或元素的特殊状态(比如<code>:hover</code>)。而<code>伪元素</code>侧重的是虚拟的元素，比如<code>:first-letter</code>，就好像<strong>真实地存在文档树中</strong>一样，但实际上是不存在的，而<code>:first-child</code>指向的元素是存在于文档树的，这是两者的不同。这大概也是为什么<code>querySelectorAll()</code>适用于<code>伪类</code>而不适用于<code>伪元素</code>的原因吧–因为前者是真实存在于DOM树，但是后者并不是。</p><h2 id="伪元素和伪类的选择器优先级">伪元素和伪类的选择器优先级</h2><p>这方面的知识是在写这篇文章不久前才接触的。总的来说，伪元素的优先级和标签的优先级是一样的，而伪类的优先级和类以及属性选择器等等的优先级是相同的。</p><p>如果就这么简单地介绍完这个小节，那也就不必大费周章了。我们来解读<a href="https://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="noopener">W3C中关于选择器优先级计算的部分</a>~</p><blockquote><p>A selector’s specificity is calculated as follows:</p><ol style="list-style-type: decimal"><li>count 1 if the declaration is from is a ‘style’ attribute rather than a rule with a selector, 0 otherwise (= a) (In HTML, values of an element’s “style” attribute are style sheet rules. These rules have no selectors, so a=1, b=0, c=0, and d=0.)</li><li>count the number of ID attributes in the selector (= b)</li><li>count the number of other attributes and pseudo-classes in the selector (= c)</li><li>count the number of element names and pseudo-elements in the selector (= d)</li></ol></blockquote><p>总的来说就是，每个行内样式(<code>style=&quot;&quot;</code>)以<code>1000</code>计，每个id选择器以<code>100</code>计，其他属性选择器和伪类选择器以<code>10</code>计，标签和伪元素选择器以<code>1</code>计，而通配符<code>*</code>以<code>0</code>计。注意，这里只是提供一个计算的方便，并不是11个类的选择器可以将一个id选择器的样式覆盖掉。</p><p>还有一点，HTML行内样式可以被JavaScript的style覆盖，而JavaScript的行内样式可以被<code>!important</code>的样式覆盖。</p><p>官方还给出了一些例子：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">*             &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></span><br><span class="line"><span class="selector-tag">li</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-line</span> &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span>+<span class="selector-tag">li</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></span><br><span class="line"><span class="selector-tag">h1</span> + *<span class="selector-attr">[rel=up]</span>&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.red</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-class">.red</span><span class="selector-class">.level</span>  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></span><br><span class="line"><span class="selector-id">#x34y</span>         &#123;&#125;  <span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></span><br><span class="line">style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br></pre></td></tr></table></figure><h2 id="层叠次序">层叠次序</h2><p>这只是选择器Selector的优先级，而样式的确定不仅仅是由选择器的优先级这一个因素来确定，还有层叠次序。</p><p>W3C规范的<a href="https://www.w3.org/TR/CSS2/cascade.html#cascading-order" target="_blank" rel="noopener">6.4.1 Cascading order</a>小节中有说明最终决定一个元素的样式的步骤：</p><blockquote><ol style="list-style-type: decimal"><li>Find all declarations that apply to the element and property in question, for the target media type.Declarations apply if the associated selector matches the element in question and the target medium matches the media list on all <span class="citation">@media</span> rules containing the declaration and on all links on the path through which the style sheet was reached.</li><li>Sort according to importance (normal or important) and origin (author, user, or user agent). In ascending order of precedence: 2.1. user agent declarations 2.2. user normal declarations 2.3. author normal declarations 2.4. author important declarations 2.5. user important declarations</li><li>Sort rules with the same importance and origin by specificity of selector: more specific selectors will override more general ones. Pseudo-elements and pseudo-classes are counted as normal elements and classes, respectively.</li><li>Finally, sort by order specified: if two declarations have the same weight, origin and specificity, the latter specified wins. Declarations in imported style sheets are considered to be before any declarations in the style sheet itself.</li></ol></blockquote><p>用图形来概括就是：</p><div class="figure"><img src="http://image.geekaholic.cn/2017-03-20_195002_0003.jpg" alt="优先级"><p class="caption">优先级</p></div><blockquote><p>Declarations in imported style sheets are considered to be before any declarations in the style sheet itself.</p></blockquote><p>英文水平有限的我，看到这句话的时候，一直搞不懂讲的是什么，误以为“import和link导入的样式会被看成是在<code>&lt;style&gt;</code>之前”。（不知道各位会翻译成什么样子呢哈哈）但是直到看<a href="http://library.salve.edu/lsc548/tutorials/css/css.html" target="_blank" rel="noopener">Cascading Styles</a>中讲到：</p><blockquote>Note: If the link to the external style sheet is placed after the internal style sheet in HTML<head><meta name="generator" content="Hexo 3.9.0"><p>, the external style sheet will override the internal style sheet!</p></head></blockquote><p>决定用例子来试试，看看那句话说的是什么。</p><div class="figure"><img src="http://image.geekaholic.cn/20170320201147.jpg" alt="代码示例"><p class="caption">代码示例</p></div><p>从图片中可以看出，样式最终选择的是<code>blue</code>，因为篇幅问题，大家可以在自己的电脑上试试，验证一下：优先级相同，以<code>&lt;style&gt;</code>，<code>&lt;link&gt;</code>的出现顺序来定义声明出现的顺序。</p><p>那最后的一句话真正的含义是什么？</p><p>我觉得应该是在讲，在<strong>同一个</strong>样式表中，<code>@import</code>的规则总是在其他规则的前面。</p><blockquote><p>In CSS 2.1, any <span class="citation">@import</span> rules must precede all other rules (except the <span class="citation">@charset</span> rule, if present). – https://www.w3.org/TR/CSS2/cascade.html#at-import</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在YY的一轮面试之后，和工作室的小伙伴一起讨论了“CSS伪类和伪元素”(因为就有一个面试问题是问“遇到过哪些伪类和伪元素，使用的场景有哪些？”)，发现牵扯进来的边边角角还是挺多的，就用一篇文章来记录一下，如果有更多涉及两者的知识点，欢迎补充~&lt;/p&gt;
&lt;h2 id=&quot;伪类和
      
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Web/"/>
    
    
      <category term="Web" scheme="http://blog.geekaholic.cn/tags/Web/"/>
    
      <category term="CSS3" scheme="http://blog.geekaholic.cn/tags/CSS3/"/>
    
      <category term="W3C" scheme="http://blog.geekaholic.cn/tags/W3C/"/>
    
  </entry>
  
  <entry>
    <title>AMD等模块化的简单原理</title>
    <link href="http://blog.geekaholic.cn/2017/03/11/AMD%E7%AD%89%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.geekaholic.cn/2017/03/11/AMD等模块化的简单原理/</id>
    <published>2017-03-11T16:36:19.000Z</published>
    <updated>2019-09-26T05:21:46.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iwo">iWo</h2><p>在正式开始之前，让我们先看看一个简易版的模块Loader是如何实现的？</p><p>感谢@爝神的<a href="https://github.com/liulyliu/iWo/blob/master/src/iwo.loader.js" target="_blank" rel="noopener">iWo.js</a>，虽然不一定符合AMD规范，而且有着一些使用限制，比如必须有id，而且路径是相对于最后加载<code>&lt;script&gt;</code>的<code>baseUrl</code>而言等等缺陷，毕竟不足100行的代码。但麻雀虽小，五脏俱全，不妨碍我们解读一个加载器的大概思想。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author xiaojue[designsor@gmail.com]</span></span><br><span class="line"><span class="comment"> * @date 20141112</span></span><br><span class="line"><span class="comment"> * @fileoverview core for iwo,a easy module control</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win, doc, undef</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;,</span><br><span class="line">        loadings = &#123;&#125;,</span><br><span class="line">        queue = [],</span><br><span class="line">        scripts = doc.getElementsByTagName(<span class="string">'script'</span>),</span><br><span class="line">        root = scripts[scripts.length - <span class="number">1</span>].src,</span><br><span class="line">        basepath = root.slice(<span class="number">0</span>, root.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">path, deps, factory</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = path;</span><br><span class="line">        <span class="keyword">this</span>.deps = factory ? deps : [];</span><br><span class="line">        <span class="keyword">this</span>.factory = factory ? factory : deps;</span><br><span class="line">        utils.addLoading(<span class="keyword">this</span>.deps);</span><br><span class="line">        cache[path] = <span class="keyword">this</span>;</span><br><span class="line">        loadings[path] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> utils = &#123;</span><br><span class="line">        addLoading: <span class="function"><span class="keyword">function</span>(<span class="params">deps</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> id = deps[i],stat = loadings[id];</span><br><span class="line">                loadings[id] = stat ? stat : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        _r: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> mod = cache[id];</span><br><span class="line">            <span class="keyword">return</span> mod.exports || (mod.exports = mod.compile());</span><br><span class="line">        &#125;,</span><br><span class="line">        checkLoading: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> loadings) &#123;</span><br><span class="line">                <span class="keyword">if</span> (loadings[id] &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        loadDeps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> loadings)&#123;</span><br><span class="line">                <span class="keyword">if</span> (loadings[id] &lt; <span class="number">1</span>) utils.loadMod(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        loadScript: <span class="function"><span class="keyword">function</span>(<span class="params">path, cb</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> script = doc.createElement(<span class="string">'script'</span>),</span><br><span class="line">                parent = doc.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">            script.onload = script.onreadystatechange = script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="regexp">/loaded|complete|undefined/</span>.test(script.readyState)) &#123;</span><br><span class="line">                    script.onload = script.onerror = script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">                    script.parentNode.removeChild(script);</span><br><span class="line">                    script = undef;</span><br><span class="line">                    <span class="keyword">if</span>(cb) cb();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            script.src = basepath + path + <span class="string">'.js'</span>;</span><br><span class="line">            parent.appendChild(script);</span><br><span class="line">        &#125;,</span><br><span class="line">        loadMod: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            loadings[id] = <span class="number">1</span>;</span><br><span class="line">            utils.loadScript(id, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (utils.checkLoading()) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">                        cache[queue.shift()].compile();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    utils.loadDeps();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        run: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">            queue.push(path);</span><br><span class="line">            utils.addLoading([path]);</span><br><span class="line">            utils.loadDeps();</span><br><span class="line">        &#125;,</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">path, deps, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Module(path, deps, factory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Module.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: Module,</span><br><span class="line">        compile: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.factory(utils._r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    win.iwo = &#123;</span><br><span class="line">        version: <span class="string">'0.0.1'</span>,</span><br><span class="line">        core: <span class="string">'iwo.core'</span>,</span><br><span class="line">        run: utils.run,</span><br><span class="line">        define: utils.define</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iwo.run(iwo.core);</span></span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><h3 id="iwo-源码概要">iWo 源码概要</h3><p>先来看看最外一层，很熟悉是不是？对，就是IIFE(立即执行函数表达式)，在很多插件的实现或者开源代码中很常见。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win, doc, undef</span>) </span>&#123;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>虽然很常见，但还是多说几句吧。</p><p>将<code>window</code>，<code>document</code>传入是为了提高效率，使得变量查找不需要再沿着作用域链向上查找，还有就是为了在压缩的时候，两者都可以被压缩，达到一定的优化。而<code>undef</code>这里因为第三个参数<strong>没有定义</strong>，所以自然获得<code>undefined</code>，而不传<code>undefined</code>是因为在一些浏览器中<code>undefined</code>的可以被修改。</p><p>接着，让我们来看看里面的成员都有哪些，有什么作用吧，从上到下分别是</p><ul><li>cache：用来存储初始化(new)的<code>Module</code>对象，key即为path，也为id，value为对应的<code>Module</code>对象</li><li>loadings：用来存储模块(或依赖的模块)的状态，key即为path，也为id，value为0时是依赖声明，value为1时是依赖加载，value为2时是模块初始化</li><li>queue：用来存储执行队列的数组</li><li>scripts：<code>script</code>标签对象</li><li>root：最后一个标签的地址</li><li>basepath：基地址(到最后的一个’/‘，包括’/’)</li><li>Module：<code>Module</code>构造函数</li><li>utils：挂载相关函数的对象<ul><li>addLoading：初始化当前模块的状态(若不存在则为0)</li><li>_r：作于<code>factory</code>的参数，在此用于<code>require(Module)</code>使用，返回<code>reuqire</code>的<code>Module</code>的返回值</li><li>checkLoading：检测是否所有模块加载并初始化</li><li>loadDeps：遍历<code>loadings</code>，调用<code>loadMod()</code>加载声明的依赖，即loadings[id]=0</li><li>loadMod：将依赖的状态进行改变为加载状态(<code>loadings[id]=1</code>)，调用<code>loadScript()</code>，并传入<code>callback</code>回调</li><li>loadScript：<strong>动态创建<code>&lt;script&gt;</code>，异步加载模块文件<code>*.js</code></strong>，监听加载事件(做了兼容处理)，加载成功(或失败)后移除标签，重置并调用回调函数<code>callback</code></li><li>run：运行模块</li><li>define：模块定义，也就是<code>new Module()</code></li></ul></li><li>Module.prototype：主要为了挂载<code>Module</code>对象的公共方法<code>compile</code><ul><li>compile：其实就是<code>Module</code>对象的<code>factory()</code>，只不过将<code>_r</code>作为实参传入，作用自然是执行<code>Module</code>的<code>factory()</code>方法，而在<code>_r()</code>中，核心代码是<code>return mod.exports || (mod.exports = mod.compile());</code>，这行代码使得<strong>依赖模块只执行一次，而不是多次，从而达到优化目的</strong></li></ul></li><li>win.iwo：将必要的变量和方法（<code>run()</code>和<code>define()</code>）挂载到全局对象window中。</li></ul><h3 id="举个栗子">举个栗子</h3><p>阅读源码的方法我个人的做法是使用调试的方法，所以自己瞎写了一些例子，让我们先来看看项目的结构。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── iWo.js</span><br><span class="line">├── mods</span><br><span class="line">│   └── module2.js</span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    └── home.html</span><br></pre></td></tr></table></figure><p>其中<code>home.html</code>是我们的测试页面，其实页面什么都没有，只是用于加载script脚本而已，核心代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- home.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../iWo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而<code>iWo.js</code>的内容就是Loader加载器了，代码已经粘贴在上面。而<code>app.js</code>是我们业务逻辑代码的入口，为了搞清楚加载流程和执行的顺序，特地增加了好几个<code>console.log()</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'loaded app.js file'</span>);</span><br><span class="line"><span class="keyword">var</span> temp;</span><br><span class="line">iwo.define(<span class="string">'module1'</span>,[<span class="string">'mods/module2'</span>],<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'executing module1'</span>);</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">'init value'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'print out temp init value in module1:'</span>+temp);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'require mods/module2'</span>);</span><br><span class="line">    temp = <span class="built_in">require</span>(<span class="string">'mods/module2'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'print out temp value after requiring module2 in module1:'</span>+temp);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'executed module1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">iwo.run(<span class="string">'module1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'print out temp value after running module in global scope:'</span>+temp);</span><br></pre></td></tr></table></figure><p>而<code>module2.js</code>为了能验证其路径的正确处理，特放在<code>mods</code>目录下面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'loaded module2.js file'</span>);</span><br><span class="line">iwo.define(<span class="string">'mods/module2'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'executing module2'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'executed module2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Module2 return value'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="执行流程">执行流程</h3><p>让我们来从<code>app.js</code>入口梳理一下整个代码执行的流程。</p><ol style="list-style-type: decimal"><li><p>打印<code>loaded app.js file</code>，说明浏览器已经加载<code>app.js</code>文件并执行该文件。</p></li><li>定义依赖于<code>mods/module2</code>的<code>module1</code>模块，执行<code>iwo.define()</code>方法，实际上是new出来一个新的<code>Module</code>对象<ol style="list-style-type: decimal"><li>对于每个新的<code>Module</code>对象都要将其依赖加入<code>loadings</code>对象中，并赋值<code>loadings[id]</code>为0，说明是依赖声明状态。而且，将<code>Module</code>对象缓存到<code>cache</code>对象中，并设置<code>loadings[id]</code>为2，说明是模块声明状态。</li><li>模块定义阶段结束。</li></ol></li><li>执行<code>iwo.run()</code>方法，执行<code>module1</code>模块<ol style="list-style-type: decimal"><li><code>queue.push(path);</code>–先将当前执行模块压入执行队列，因为要先加载其依赖，方可执行当前模块。</li><li><code>utils.addLoading([path]);</code>–标明当前模块的状态。(PS:但是我个人认为<code>Module</code>对象的状态已经在<code>new</code>的时候标注为<code>2</code>，这里显得多此一举，暂时不知道该步骤为了考虑什么情况。若大家知道，可以在评论区指出，谢谢~)</li><li><code>utils.loadDeps();</code>–加载当前模块的依赖。具体的工作原理是怎么样的？该方法遍历<code>loadings</code>对象，如果<code>loadings[id]</code>的值小于1，说明是依赖声明状态，并未加载依赖文件，这时候调用<code>loadMod(id)</code>方法</li><li><code>loadMod(id)</code>–先是改变<code>loadings[id]</code>的状态为“依赖加载”，也就是“1”，然后调用<code>loadScript(id,callback)</code>方法</li><li><code>loadScript(id,callback)</code>–其实就是根据<code>id</code>构建出<code>src</code>，动态创建<code>&lt;script&gt;</code>标签将依赖的模块所在文件异步加载，并监听新创建标签的<code>onload</code>/<code>onerror</code>/<code>onreadystatechange</code>事件，当事件完成后移除创建的标签并且重置<code>script</code>标签对象的各个变量，最后调用<code>callback()</code>。这里需要注意的是，<code>onreadystatechange</code>是为了处理ie下的兼容性，因为在<a href="http://kangax.github.io/jstests/script-element-onload-attribute-support/" target="_blank" rel="noopener">IE9以下版本的IE中<code>script</code>标签不支持<code>onload</code>和<code>onerror</code></a>，所以使用<code>onreadystatechange</code>进行替代，但是还有一个问题，重置<code>script</code>对象下的变量不仅是为了垃圾回收机制，更多的是为了避免某些浏览器(如IE9)触发两次事件。可以查看<a href="http://www.aaronpeters.nl/blog/prevent-double-callback-execution-in-IE9" target="_blank" rel="noopener">这篇久远的国外文章</a>进行简单的了解</li><li>当<code>mods/module2.js</code>加载进来的时候，又一次开始执行<code>iwo.define()</code>，再一次进入模块定义阶段，初始化<code>mods/module2</code>模块。</li><li>当加载的<code>mods/module2.js</code>执行结束后，意味着<code>mods/module2</code>已经定义好了。这时候就会调用<code>callback()</code>方法了。</li><li><code>callback()</code>–这个方法的主要任务是调用<code>checkLoading()</code>检测依赖是否都已经加载进来，如何检测？对，就是利用<code>loadings[id]</code>的状态值，当所有的<code>loadings[id]</code>都为2(也就是所有模块文件都加载进来，都定义好了)的时候，就会根据执行队列的模块长度，从第一个开始进行执行。这里有一个妙用，<code>queue.shift()</code>这样就能保证从头到尾按照顺序执行模块。具体的执行是调用了挂载在<code>Module</code>原型上的<code>compile()</code>方法，实质上是其对应模块的<code>factory()</code>的执行，唯一的差别在于其可以传递<code>require</code>进行导出结果操作。</li></ol></li></ol><h3 id="结果与简要分析">结果与简要分析</h3><p>上面的代码例子执行结果如下图所示：</p><div class="figure"><img src="http://image.geekaholic.cn/2017-03-15_142611_0001.jpg" alt="执行结果"><p class="caption">执行结果</p></div><p>由一二条打印结果可以看出，模块加载是异步的，而且模块内部的变量无法被外部全局访问，而第3，4条打印结果可以告诉我们，<code>module1</code>的执行是先加载并定义<code>mods/module2</code>，但是并没有运行<code>mods/module2</code>的<code>factory</code>函数，<code>mods/module2</code>的<code>factory()</code>函数真正执行的时机在于<code>require('mods/module2')</code>，所以从这点上来看，<strong><code>iwo.js</code>这一个特点更像是<code>CMD规范</code>的懒执行</strong>。</p><p>可以看出，一个简单的模块加载器，最起码需要有：</p><ul><li>异步加载脚本</li><li>依赖检测、分析与加载</li></ul><p>而如果你想了解<code>JavaScript异步加载</code>的多种加载方式(其中属<code>动态创建DOM节点</code>最为常用)，以及<code>JavaScript延迟执行</code>的方法，可以查看以下两个链接：</p><ul><li><p><a href="http://coolshell.cn/articles/9749.html" target="_blank" rel="noopener">JAVASCRIPT 装载和执行</a></p></li><li><p><a href="http://www.infoq.com/cn/articles/browser-resource-loading-optimization" target="_blank" rel="noopener">让我们再聊聊浏览器资源加载优化</a></p></li></ul><p>其中第二个文章的分析也不仅仅讲的是加载和执行，干货满满，非常值得一看。</p><p>而这里还是要再说明一下，<code>JavaScript延迟执行</code>与<code>factory函数懒执行</code>说的是两码事。以<code>iWo.js</code>为例子，动态创建DOM的方式加载js脚本的时候，当一加载完成就会执行该外部脚本，否则哪里来的<code>define</code>。而<code>factory函数懒执行</code>只不过是调用该<code>factory</code>函数是在<code>require</code>相应模块的时候。</p><p>End.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iwo&quot;&gt;iWo&lt;/h2&gt;
&lt;p&gt;在正式开始之前，让我们先看看一个简易版的模块Loader是如何实现的？&lt;/p&gt;
&lt;p&gt;感谢@爝神的&lt;a href=&quot;https://github.com/liulyliu/iWo/blob/master/src/iwo.loade
      
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Web/"/>
    
    
      <category term="JavaScript" scheme="http://blog.geekaholic.cn/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://blog.geekaholic.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript模块化的一二事</title>
    <link href="http://blog.geekaholic.cn/2017/03/09/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%8C%E4%BA%8B/"/>
    <id>http://blog.geekaholic.cn/2017/03/09/JavaScript模块化的一二事/</id>
    <published>2017-03-09T15:42:18.000Z</published>
    <updated>2019-09-26T05:21:46.903Z</updated>
    
    <content type="html"><![CDATA[<p>在前端发展迅速的今天，模块化已经不是什么新的名词。在查阅资料之前，本人对模块化一知半解，“不就引用sea.js或者require.js的事吗”。其实，学习技术怕的不就是只知道皮毛就以为自己懂了吗？（注：<code>sea.js</code>已经不再维护）</p><p>不敢说对整篇文章说讲的都全部掌握，只求能比之前懵懂的状态前进一点。</p><h2 id="js模块化解决的是什么">js模块化解决的是什么</h2><p>一个工具流行，必然是它解决了当前的某个痛点，满足了人们的需求。就好像jQuery，它封装了DOM的常用操作，并处理了浏览器的兼容性，使得人们操作DOM更加方便。而JavaScript模块化工具必然也是解决了某一类问题。</p><p>在学习C语言的时候，都能清楚地知道模块化的重要性–代码复用以及高内聚低耦合，不仅是为了可维护也是为了代码的健壮性。而在JavaScript中，解决的是什么？</p><p>–当一个项目逐渐复杂，多个人进行开发的时候，难免会出现命名冲突的问题，还有一个就是前端开发并不像后端一样，有专门的工具进行管理依赖，只以script标签的出现顺序来简略地规定文件的依赖关系。所以<strong>命名冲突</strong>和<strong>文件依赖</strong>是JavaScript模块化解决的主要问题，它的好处自然是可维护性和复用性。</p><h3 id="命名冲突">命名冲突</h3><p>在<code>sea.js</code>等工具的出现之前，我们的JavaScript代码是如何组织的？或者说模块化开发的整个演变过程是如何的？</p><h4 id="全局函数">全局函数</h4><p>这种方式前期最常见的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>试想一下，如果全局中也有一个变量和函数同名，会导致什么后果？变量提升的时候，函数声明的优先级是高于变量的，所以会导致函数声明被覆盖(不管这个变量在函数声明之前还是之后都是一样的)</p><p>缺点：全局命名空间被污染，很容易造成命名冲突。</p><h4 id="简单的命名空间">简单的命名空间</h4><p>我们知道不同的对象可以有不同的成员，包括变量和函数。这样我们可以将变量和函数都挂载在特定的自定义对象下，只能通过对象来引用其内部成员，达到命名空间的效果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//objBase.js</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'add'</span>)&#125;,</span><br><span class="line">  minus: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'minus'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add();//出错</span></span><br><span class="line">obj.add();<span class="comment">//console:'add'</span></span><br></pre></td></tr></table></figure><p>优点：减少了全局变量。 缺点：1. 对象的成员都被暴露，可以被外界修改，无私有成员可言。2. 当命名空间过长时，造成记忆负担。</p><h4 id="闭包">闭包</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//objBase.js</span></span><br><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> addText = <span class="string">'add'</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(addText)&#125;;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    add: add</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">obj.add();<span class="comment">//'add'</span></span><br><span class="line">obj.addText= <span class="string">'add Changed!'</span>;</span><br><span class="line">obj.add();<span class="comment">//'add'</span></span><br></pre></td></tr></table></figure><p>优点：1. 减少了全局变量，一定程度上解决了变量命名冲突。2. 可以选择性地将内部成员暴露给外部接口。</p><h4 id="闭包依赖注入">闭包依赖注入</h4><p>让我们为上面的闭包再增强一点，给它<strong>注入依赖</strong>，并且让它更加易于拓展。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//objBase.js</span></span><br><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这时可以使用$作为jQuery对象</span></span><br><span class="line">  <span class="keyword">var</span> addText = <span class="string">'add'</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(addText)&#125;;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    add: add</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure><p>优点：高内聚低耦合，根据需要注入不同的依赖。</p><p>确实，只要在全局中存在<code>$</code>变量就可以在匿名函数中使用，但是这样不利于后期代码的维护。因为在维护的后期你很有可能不记得<code>obj</code>的依赖有哪些，而注入依赖会使得代码更加清晰。</p><h4 id="闭包的高级模式">闭包的高级模式</h4><p>(PS:Hexo-admin插件会莫名丢失<code>draft</code>中的内容，再也不用该插件了。心累…)</p><p>看起来闭包已经足够使用，但是当基础模块<code>objBase.js</code>需要扩展的时候，在源文件进行修改是不妥当的，因为可能会把新的bug引入原有已经测试通过的模块中，这会导致在原有模块中定位错误相当困难。这也是面向对象中的<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开闭原则</a> – 允许在改变它的源代码的前提下变更它的行为。 这就需要我们在扩展模块<code>objExtend.js</code>等文件中进行拓展。</p><p>而这需要用到闭包的高级用法，而且不同需求对应不同的扩展模式。其实说是高级用法，其实还是用的基础知识，但是思想很值得我们去学习。高级用法有好多，还请根据自己的需求进行选择。</p><h5 id="扩展">扩展</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//objExtend.js</span></span><br><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params">myObj,$</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这时可以使用$作为jQuery对象</span></span><br><span class="line">  obj.minus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> myObj;</span><br><span class="line">&#125;)(obj,jQuery);</span><br></pre></td></tr></table></figure><p>需求：将一个模块分离到多个文件，<strong>同步加载</strong>模块文件。</p><p>缺点：需要保证<code>obj</code>在<code>objExtend.js</code>加载前已经存在，所以需要同步加载，先加载<code>obj</code>基础模块。</p><h5 id="松耦合扩展">松耦合扩展</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params">myObj,$</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这时可以使用$作为jQuery对象</span></span><br><span class="line">  obj.minus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> myObj;</span><br><span class="line">&#125;)(obj||&#123;&#125;,jQuery);</span><br></pre></td></tr></table></figure><p>需求：将一个模块分离到多个文件，<strong>异步加载</strong>模块文件(无论基础模块还是扩展模块)。</p><p>Tips：其实是应用了<code>||</code>操作符的短路操作，JavaScript中比较常见。</p><p>缺点：松耦合扩展不能和<code>闭包依赖注入</code>等返回新对象的模块模式进行混合使用，否则会覆盖。试想一下，当返回新对象的<code>*.js</code>文件后加载，会是怎样的情况？</p><h5 id="紧耦合扩展">紧耦合扩展</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span>(<span class="params">myObj,$</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 这时可以使用$作为jQuery对象</span></span><br><span class="line">  <span class="keyword">var</span> old_add = obj.add;</span><br><span class="line">  obj.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*use old_add*/</span>&#125;</span><br><span class="line">  obj.minus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> myObj;</span><br><span class="line">&#125;)(obj,jQuery);</span><br></pre></td></tr></table></figure><p>需求：将一个模块分离到多个文件，<strong>同步加载</strong>模块文件，覆盖原有属性或函数并且需要用到原有属性或函数。</p><p>缺点：同步加载。</p><h5 id="跨文件共享私有对象">跨文件共享私有对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> _private = my._private = my._private || &#123;&#125;,</span><br><span class="line">_seal = my._seal = my._seal || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> my._private;</span><br><span class="line"><span class="keyword">delete</span> my._seal;</span><br><span class="line"><span class="keyword">delete</span> my._unseal;</span><br><span class="line">&#125;,</span><br><span class="line">_unseal = my._unseal = my._unseal || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">my._private = _private;</span><br><span class="line">my._seal = _seal;</span><br><span class="line">my._unseal = _unseal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// permanent access to _private, _seal, and _unseal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> my;</span><br><span class="line">&#125;(MODULE || &#123;&#125;));</span><br></pre></td></tr></table></figure><p>以上代码可以在<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">英文原文</a>中找到，使用<code>松耦合扩展</code>模式对内部私有属性进行维护，从而达到模块内的多个文件访问私有对象。</p><blockquote><p>Any file can set properties on their local variable _private, and it will be immediately available to the others. Once this module has loaded completely, the application should call MODULE._seal(), which will prevent external access to the internal _private. If this module were to be augmented again, further in the application’s lifetime, one of the internal methods, in any file, can call _unseal() before loading the new file, and call _seal() again after it has been executed. This pattern occurred to me today while I was at work, I have not seen this elsewhere. I think this is a very useful pattern, and would have been worth writing about all on its own.</p></blockquote><p>需求：将一个模块分离到多个文件，私有对象模块内跨文件共享。</p><p>Tips：可以看到<code>_seal()</code>是使用了<code>delete</code>删除属性的操作符，而<code>_unseal()</code>使用了重新赋值的方法。</p><p>缺点：代码冗余。</p><p>根据英文原文中的意思，“一个模块的所有文件都可以访问私有属性，提倡模块加载结束后调用<code>_seal()</code>，而如果需要加载新的模块文件，先调用<code>_unseal()</code>，加载完成后，再调用<code>_seal()</code>”，但是由于使用了<code>松耦合扩展</code>，说明模块加载无法保证顺序，这就意味着<code>_seal</code>和<code>_unseal</code>方法都要在该模块的每一个文件中。还有一个问题，“Once this module has loaded completely, the application should call MODULE._seal()“。这没有问题，但是</p><blockquote><p>“If this module were to be augmented again, further in the application’s lifetime, one of the internal methods, in any file, can call _unseal() before loading the new file, and call _seal() again after it has been executed.&quot;</p></blockquote><p>这似乎就说不过去了。</p><p>因为调用<code>Module._seal()</code>的时候<code>delete my._unseal;</code>，会失去<code>_unseal</code>的引用，在新增加模块文件之前，自然无法调用<code>Module._unseal()</code>，导致出错。而且跨文件访问私有属性很难管理。我找到了作者在评论讨论的一番话，当时的内心Orz…</p><blockquote><p>I’ve never actually used it, which is probably a good sign that it’s not useful. I was mostly just trying to prove that you COULD do something like that with the Module Pattern, and to show the flexibility of JavaScript.</p></blockquote><div class="figure"><img src="http://image.geekaholic.cn/20170310103317.png" alt="讨论详情"><p class="caption">讨论详情</p></div><p>文章挺久远的了，但是不妨碍我们学习其思想:)</p><h3 id="文件依赖">文件依赖</h3><p>后端开发中有专门的依赖管理软件或者包管理软件，比如<code>Java</code>中的<code>Maven</code>和<code>Gradle</code>，<code>nodejs</code>中的<code>npm</code>，而在前端中的前期是如何管理依赖的？</p><p><code>&lt;script&gt;</code>的出现顺序或者代码出现的顺序。</p><p>就好像引入jQuery插件的时候，<code>jQuery</code>文件一定需要在这插件引入之前引入。这似乎没什么毛病啊，但当一个项目越来越庞大的时候，或者依赖关系出现闭环、相互依赖等复杂关系的时候，就会出现难以维护，依赖难以管理，请求过多等弊端了。</p><p>而且要知道，前面的模块模式虽然可以注入依赖，但是模块导出都是存在单个全局变量，有时候我们只是基于一个存在的模块构建另外一个模块，而不是都将其挂载在全局变量中。</p><p><a href="https://huangxuan.me/js-module-7day/#/11" target="_blank" rel="noopener">PPT</a>的例子如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body</span><br><span class="line">    script(src=<span class="string">"zepto.js"</span>)</span><br><span class="line">    script(src=<span class="string">"jhash.js"</span>)</span><br><span class="line">    script(src=<span class="string">"fastClick.js"</span>)</span><br><span class="line">    script(src=<span class="string">"iScroll.js"</span>)</span><br><span class="line">    script(src=<span class="string">"underscore.js"</span>)</span><br><span class="line">    script(src=<span class="string">"handlebar.js"</span>)</span><br><span class="line">    script(src=<span class="string">"datacenter.js"</span>)</span><br><span class="line">    script(src=<span class="string">"deferred.js"</span>)</span><br><span class="line">    script(src=<span class="string">"util/wxbridge.js"</span>)</span><br><span class="line">    script(src=<span class="string">"util/login.js"</span>)</span><br><span class="line">    script(src=<span class="string">"util/base.js"</span>)</span><br><span class="line">    script(src=<span class="string">"util/city.js"</span>)</span><br><span class="line">    script(src=<span class="string">"util/date.js"</span>)</span><br><span class="line">    script(src=<span class="string">"util/cookie.js"</span>)</span><br><span class="line">    script(src=<span class="string">"app.js"</span>)</span><br></pre></td></tr></table></figure><p>所以我们需要一些工具，比模块模式更加好用，既可以避免全局变量冲突(模块模式的冲突避免得不够彻底)，还可以明确代码直接的依赖关系，更重要的是模块声明的方式让编写代码更加舒适。</p><h2 id="js模块化工具">js模块化工具</h2><h3 id="模块定义和加载方案">模块定义和加载方案</h3><h4 id="一些历史">一些历史</h4><p><code>CMD</code>和<code>AMD</code>这部分纯属科普向，<code>RequireJS</code>和<code>SeaJS</code>都是历史阶段性的产物，也权当了解即可。</p><p>JavaScript 模块化最早是出现在<code>Nodejs</code>当中，推出了<code>Module/1.0</code>规范并获得不错的成功后，想继而推广到浏览器端的时候，出现了分歧，形成了三大流派，大致如下：</p><div class="figure"><img src="http://image.geekaholic.cn/p978yzq5wzv76ep29wn4hwjl73" alt="CommonJS流派"><p class="caption">CommonJS流派</p></div><p>如果你想了解这部分历史，请翻阅玉伯大大的<a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="noopener">前端模块化开发那点历史</a>。</p><p>我们在这里简单地探讨一下<code>AMD规范</code>和<code>CMD规范</code>两者的实现，即<code>RequireJS</code>和<code>SeaJS</code>，有哪些不同。</p><h4 id="amd与cmd">AMD与CMD</h4><p>AMD(Async Module Definition)是RequireJS对模块定义的规范化产出，而CMD(Common Module Definition)是SeaJS对模块定义的规范化产出。所以CMD和CommonJS不是说的同一个东西。这里不展开探讨，也没有意义，只简单地总结AMD和CMD的相同点和代码方式上的差别。</p><ul><li>两者都是异步加载模块文件，而NodeJS的CommonJS是同步</li><li>CMD推崇依赖就近，AMD推崇依赖前置(原因看下面一条)</li><li>CMD 是延迟执行，as lazy as possible，也就是而AMD是提前执行，也就是加载完成后立即执行。</li></ul><p>关于第3点，或许看<a href="https://github.com/seajs/seajs/issues/588#issuecomment-19682315" target="_blank" rel="noopener">代码例子</a>更容易理解一些。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 模块 a 和 b 在这里就都执行好并可用了</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>)  <span class="comment">// 模块 a 运行到此处才执行</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>)   <span class="comment">// 当某些条件为 false 时，模块 b 永远也不会执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="umd">UMD</h4><blockquote><p>在一些同时需要AMD和CommonJS功能的项目中，你需要使用另一种规范：Universal Module Definition（通用模块定义规范）。</p></blockquote><p>这种模式的使用方法因为其兼容性好，兼顾了AMD、CommonJS和客户端，在开源类库或者自己实现某个原生插件、功能时比较常见。基本的代码框架如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returnExports.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD. Register as an anonymous module.</span></span><br><span class="line">        define([<span class="string">'b'</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">        <span class="comment">// Node. Does not work with strict CommonJS, but</span></span><br><span class="line">        <span class="comment">// only CommonJS-like environments that support module.exports,</span></span><br><span class="line">        <span class="comment">// like Node.</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'b'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">        root.returnExports = factory(root.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//use b in some fashion.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just return a value to define the module export.</span></span><br><span class="line">    <span class="comment">// This example returns an object, but the module</span></span><br><span class="line">    <span class="comment">// can return a function as the exported value.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>原理就是一个IIFE，并且加上判断，判断是否存在AMD，存在CommonJS，否则将其挂载到全局对象。</p><p>如果你想看更多的例子：见官方<a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">Repo</a></p><h4 id="es6-module">ES6 Module</h4><p>前端模块化的重要性逐渐显现出来，ECMAScript在ES2015也就是ES6中引入了模块的功能。</p><p>ES6默认一个文件一个模块，也就是说，在一个模块文件里面声明的任何东西都是默认私有的，如果想变为<code>public</code>，需要使用<code>export</code>命令。还有很重要的一点，ES6的<strong>import是实时只读的</strong>。</p><p>对于<code>export</code>命令来说，有两种导出方式，一种是命名导出，一种是默认导出。一般来说，导出多个值的时候使用命名导出，导出一个值比如一个函数，一个类或者一个对象等使用默认导出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//multiple named export</span></span><br><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者使用一次导出多个</span></span><br><span class="line"><span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;sqrt,square,diag&#125;;</span><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="comment">//使用命名导出多个值时必须使用相同的名称进行引用，当然可以使用`as`对其名称重命名，export也可以使用`as`关键字</span></span><br><span class="line"><span class="keyword">import</span> &#123; square, diag <span class="keyword">as</span> d &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></span><br><span class="line"><span class="built_in">console</span>.log(d(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//或者使用`*`引入全部</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lib.square(<span class="number">11</span>)); <span class="comment">// 121</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Single default export</span></span><br><span class="line"><span class="comment">//------ MyClass.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ··· &#125; <span class="comment">// no semicolon!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main2.js ------</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><p>基本的用法如上所示，如果想查看更加高级的用法，比如两种方式混合导出等可以查阅专门的文章或者期待我的<a href="/tags/ES6/">ES6学习日记</a>~</p><p>好处是它是一个标准，而且<strong>实时更新</strong>，然而残酷的现实是浏览器支持度全线飘红，不过可以通过<code>Babel</code>等工具进行代码转换。</p><div class="figure"><img src="http://image.geekaholic.cn/2017-03-10_173025_0001.jpg" alt="兼容性"><p class="caption">兼容性</p></div><h3 id="模块打包构建方案">模块打包构建方案</h3><p>AMD和CMD是在前端引入<code>RequireJS</code>或者<code>SeaJS</code>的脚本，在线加载解释器并对代码进行编译，从而达到模块化管理的目的。ES6 Module是JavaScript原生支持，但目前浏览器的兼容性不理想，需要通过<code>Bable</code>转换。</p><p>其实除了上述两者之外，JavaScript前端模块化还有一种解决方案，是通过<code>Node</code>和相应的工具，本地预编译，不需要在前端加载解释器，将模块化的代码打包处理(合并和压缩等)，而浏览器端的代码引入只需要引入打包处理后的<strong>一个文件</strong>，比如<code>&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</code>即可。而这种解决方案目前流行的有两款工具：<code>Browserify</code>和<code>Webpack</code>。</p><p>（ 注意<code>Babel</code>和<code>Browserify</code>、<code>Webpack</code>不是同一类工具，前者用于转换ES6代码，以达到更强的浏览器兼容性，而后者是构建工具，用于压缩合并等功能。 ）</p><h4 id="browserifycommonjs">Browserify+CommonJS</h4><blockquote><p>Browsers don’t have the <code>require</code> method defined, but Node.js does. With Browserify you can write code that uses <code>require</code> in the same way that you would use it in Node.</p></blockquote><p>在<code>Node.js</code>中，CommonJS是同步载入的，对于浏览器来说并不理想。而<code>Browserify</code>的作用就是将CommonJS模块(或者纯前端脚本)转换为浏览器可以调用的格式。然后<code>Browserify</code>通过抽象语法树（AST）来解析代码中的每一个 <code>require</code> 语句，在分析完所有模块的依赖和结构之后，就会把所有的代码合并到一个文件中。它还有一个好处就是，可以让前端<code>JavaScript</code>模块直接使用<code>npm install</code>的方式进行安装，比如<code>npm install backbone jquery</code>安装backbone和它所依赖的jQuery模块。</p><p>而如果你想在<code>Browserify</code>中使用<code>AMD</code>模块语法，可以看一下这款插件<a href="https://www.npmjs.com/package/deamdify" target="_blank" rel="noopener">deamdify</a>或者下面的解决方案。</p><p>而如果你想使用AMD的语法以及<code>RequireJS</code>来异步加载模块，可以使用<code>RequireJS optimizer</code>, <code>r.js</code>一类的构建工具来合并和压缩AMD的模块。同理，<code>SeaJS</code>可以使用<code>spm</code>。</p><p><code>Browserify</code>的基本用法是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">browserify main.js -o bundle.js</span><br></pre></td></tr></table></figure><p>如果你想详细了解<code>Browserify</code>的用法、例子，可以查看其<a href="http://browserify.org/" target="_blank" rel="noopener">官网</a>或者<a href="http://zhaoda.net/2015/10/16/browserify-guide/" target="_blank" rel="noopener">Browserify 使用指南</a></p><h4 id="rollup-tree-shaking">Rollup – tree shaking</h4><blockquote><p>Rollup is a module bundler for JavaScript which compiles small pieces of code into a something larger and more complex, such as a library or application. It uses the new standardized format for code modules included in the ES6 revision of JavaScript, instead of previous idiosyncratic solutions such as CommonJS and AMD.</p></blockquote><p>从官网的介绍可以看到<code>RollupJS</code>作为打包工具，有一些优点：</p><ul><li>ES6原生语法</li><li>Tree shaking</li><li>转换为AMD,CommonJS,UMD,IIFE等方式</li></ul><p>关于什么是<code>Tree shaking</code>，官方的定义是：</p><blockquote><p>Tree-shaking a.k.a. ‘live code inclusion’ is the process of only including the code that is used. It is similar to dead code elimination but can be more efficient</p></blockquote><p>简单地来说，是一种减少代码冗余的技术，只加载需要调用的代码，而不是加载全部，这样就不怕载入的依赖存在冗余了。</p><p>但是很不幸，以上的优点在最新版本v2.2的<code>Webpack</code>中都已经实现了。</p><h4 id="webpack-一切皆模块">Webpack – 一切皆模块</h4><p>目前主流的前端构建工具，估计属<code>Webpack</code>是最热的了吧。</p><p>虽然Webpack和Browserify都是模块化打包工具，但是两者面向的方面可是大有不同。<code>Browserify</code>是一个为浏览器环境提供Node模块的模块打包工具，而<code>Webpack</code>不仅仅是将<code>JavaScipt</code>纳入模块化的范畴，图片、样式文件等资源也可以进行模块化、打包等，在很多人(包括我)看来，<code>Webpack</code>不仅仅是JavaScript模块化工具，依赖其强大的插件，也包含了<code>gulp</code>的大部分功能，可以说是大而全的前端工程化工具，也就是说<code>Webpack 约等于 gulp+Browerify</code>。当然，也有使用<code>Webpack+gulp</code>的（将Webpack做打包工具，gulp做自动化工具），这些工具的使用暂时不是很熟悉，就不献丑了。</p><p>回到正题，Webpack提供的模块化思想似乎更加的先进，可以使用<code>code splitting</code>这样的功能，将代码分割成一个个的chunk，然后实现按需加载进行性能优化。</p><p>Webpack在JavaScript模块化方面的简单使用和<code>Browserify</code>很类似。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack main.js bundle.js</span><br></pre></td></tr></table></figure><p>如果你想对比<code>Webpack</code>和<code>Browserify</code>之间的区别，可以查看文章<a href="http://blog.namangoel.com/browserify-vs-webpack-js-drama" target="_blank" rel="noopener">Browserify VS Webpack - JS Drama</a>和<a href="http://webpack.github.io/docs/comparison.html" target="_blank" rel="noopener">Webpack官方的对比</a>，或者<a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="noopener">看看<code>Webpack</code>可以为你提供什么</a></p><h4 id="最优解">最优解</h4><p>所以，介绍了那么多的工具，目前(2017/3/10)的最优方案应该是什么？</p><p>个人意见是<code>ES6+Webpack2.2(需要安装相关的Babel插件)</code>或者<code>ES6+RollupJS+gulp等</code>，至于如何还请根据自己的项目要求~</p><h2 id="结束">结束？</h2><p>这篇文章讲了什么？无外乎模块化历史的发展。学到了几种模块模式，懂得了<code>UMD</code>（之前知道这种写法，但不清楚术语），还见识到了前端发展的迅速。</p><p>因为中间<code>hexo-admin</code>插件抽风了，让我一个下午的写作没有保存。本来一天可以写完的硬是花了我两天的时间来写这篇文件，我能怎么办QAQ我也很绝望啊。讲了那么多，无外乎一些历史和简单的介绍，到底模块化<code>AMD</code>等内部是如何实现的，内部是怎么样的原理，似乎没有讲到。想接着大致地分析内部的原理，虽然知道异步加载模块的原理是通过动态生成<code>&lt;script&gt;</code>标签，却怕自己的能力不够分析那么多。</p><p>考虑到时间、篇章和能力的限制，暂且到此结束该篇，将其他部分的内容后移:)</p><ul><li><p>JavaScript模块化加载器的大概原理</p></li><li><p>Webpack的使用和ES6 Module的详细介绍</p></li></ul><hr><p>** 参考资料：**</p><ul><li><p><a href="https://huangxuan.me/js-module-7day/#/" target="_blank" rel="noopener">JavaScript模块化七日谈</a></p></li><li><p><a href="http://www.jianshu.com/p/3832c00a44a7?utm_source=caibaojian.com" target="_blank" rel="noopener">JavaScript中的模块化开发</a></p></li><li><p><a href="http://www.oschina.net/translate/javascript-module-pattern-in-depth#content_h2_5_5" target="_blank" rel="noopener">深入理解JavaScript 模块模式–高级模式</a></p></li><li><p><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">JavaScript Module Pattern: In-Depth</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22945985" target="_blank" rel="noopener">JavaScript 模块化入门Ⅱ：模块打包构建</a></p></li><li><p><a href="https://github.com/boxizen/boxizen.github.io/issues/9" target="_blank" rel="noopener">RequireJS, Sea.js, Browserify和webpack的对比</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前端发展迅速的今天，模块化已经不是什么新的名词。在查阅资料之前，本人对模块化一知半解，“不就引用sea.js或者require.js的事吗”。其实，学习技术怕的不就是只知道皮毛就以为自己懂了吗？（注：&lt;code&gt;sea.js&lt;/code&gt;已经不再维护）&lt;/p&gt;
&lt;p&gt;不敢
      
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Web/"/>
    
    
      <category term="JavaScript" scheme="http://blog.geekaholic.cn/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://blog.geekaholic.cn/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>制作Hexo主题详细教程（2）</title>
    <link href="http://blog.geekaholic.cn/2017/03/06/%E5%88%B6%E4%BD%9CHexo%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <id>http://blog.geekaholic.cn/2017/03/06/制作Hexo主题详细教程（2）/</id>
    <published>2017-03-06T11:02:00.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<p>接着<a href="/2017/02/22/制作Hexo主题详细教程（1）/">上一次的教程</a>,还有一些细节没有讲，分别是配置文件、第三方服务、自定义辅助器、<del>主题的小功能</del>等。</p><h2 id="配置文件">配置文件</h2><h3 id="格式">格式</h3><p>Hexo 主题使用 <code>YAML</code> 语言作为配置文件，<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">阮一峰老师的博文</a>对这种语言进行了详细的介绍。</p><blockquote><p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。</p></blockquote><p>虽然简洁和方便，但是对于习惯了JSON的我来说，还是不大习惯。</p><p>这里以<code>ylion</code>主题中的部分配置为例子，要想学习更多，还请翻阅阮一峰老师的博文，讲的清晰易懂。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">notification</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">popular</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">tagcloud</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends</span></span><br></pre></td></tr></table></figure><p>转换为JSON格式就是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">widgets:[</span><br><span class="line">    <span class="string">'notification'</span>,</span><br><span class="line">     <span class="string">'category'</span>,</span><br><span class="line">     <span class="string">'archive'</span>,</span><br><span class="line">     <span class="string">'popular'</span>,</span><br><span class="line">     <span class="string">'tagcloud'</span>,</span><br><span class="line">     <span class="string">'friends'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再以菜单栏部分为例子：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">- page:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  url:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  icon:</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">- page:</span> <span class="string">rss</span></span><br><span class="line"><span class="attr">  url:</span> <span class="string">/atom.xml</span></span><br><span class="line"><span class="attr">  icon:</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure><p>转换为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">menu: [</span><br><span class="line">    &#123; <span class="attr">page</span>: <span class="string">'home'</span>, <span class="attr">url</span>: <span class="string">'/'</span>, <span class="attr">icon</span>: <span class="string">'fa-home'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">page</span>: <span class="string">'rss'</span>, <span class="attr">url</span>: <span class="string">'/atom.xml'</span>, <span class="attr">icon</span>: <span class="string">'fa-rss'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上都是复合结构的应用。字符串数据类型的应用在ylion主题的应用也是广泛的。<code>YAML</code>还支持在字符串中插入HTML标记。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cc:</span> <span class="string">|-</span></span><br><span class="line">        <span class="string">&lt;a</span> <span class="string">href="https://creativecommons.org/licenses/by-nc-nd/3.0/"</span> <span class="string">target="_blank"&gt;</span></span><br><span class="line">        <span class="string">知识共享署名-非商业性使用-禁止演绎</span> <span class="number">3.0</span> <span class="string">未本地化版本许可协议（CC</span> <span class="string">BY-NC-ND</span> <span class="number">3.0</span><span class="string">）</span></span><br><span class="line">        <span class="string">&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p><strong>为了在模版引擎部分如EJS中更容易读取到自己所需要的数据，请选择合适的数据类型并组织好自己的配置文件结构！</strong></p><h3 id="如何读取">如何读取</h3><p>为什么要在脑海中将 <code>YAML</code>格式转换为 <code>JSON</code> 格式？ 自然是为了方便已经习惯了 <code>JSON</code> 思维的我们，这也是为了能在<code>EJS</code>的逻辑部分方便获取。</p><p>以<a href="https://github.com/GeekaholicLin/hexo-theme-ylion/blob/master/layout/_partial/sidebar.ejs#L1-#L8" target="_blank" rel="noopener">sidebar</a>部分为例子，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if(theme.widgets&amp;&amp;theme.widgets.length&gt;0)&#123;%&gt;</span><br><span class="line">&lt;ul id=&quot;sidebar&quot;&gt;</span><br><span class="line">    &lt;% theme.widgets.forEach(function(widget)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&apos;_widget/&apos; + widget) %&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure><p>如果主题配置文件中的<code>widgets</code>变量(<code>theme.widgets</code>)存在且给变量的长度大于0，则对其进行遍历，并将<code>_widget</code>目录下的对应名字的ejs文件加载进来。</p><p>如果获取到undefined或者运行<code>hexo g</code>命令生成预览的时候出错，很大的可能是你的配置文件出错(比如不适当的缩进)或者你获取的方式不对。</p><p><strong>Tips:</strong> 利用<a href="http://nodeca.github.io/js-yaml/" target="_blank" rel="noopener">线上工具</a>对自己的配置进行转换看看，是否获取正确。如果你不想使用该种方法，也可以使用笨方法<code>console.log()</code>或者<code>console.dir()</code>，将获取的变量打印在Terminal，看是否准确。</p><h2 id="第三方服务">第三方服务</h2><p>Github Pages 提供给我们的是静态的网页，也就是说，并没有后台管理系统让我们对我们的博客、留言、阅读量等进行线上管理。但是我们可以通过集成第三方服务的方式达到目的。ylion主题中的第三方服务大致上有：</p><ul><li>leancloud: 阅读量的统计和热门文章</li><li>多说: 留言管理</li><li>不蒜子: 整站访客人数统计</li><li>百度和谷歌: 站点统计和管理</li></ul><p>其实集成第三方服务，最主要的也还是看文档(这不是废话吗…)。在实现ylion主题的过程中，属leancloud的集成最为困难，而且坑比较多。所以就以<code>leancloud</code>的集成为例子作为该部分的例子进行讲解吧。</p><h3 id="hexo与leancloud">Hexo与Leancloud</h3><p>Leancloud的入门知识请查看<a href="https://leancloud.cn/docs/leanstorage-started-js.html" target="_blank" rel="noopener">官方链接</a>以及<a href="https://leancloud.cn/docs/sdk_setup-js.html" target="_blank" rel="noopener">JavaScript SDK安装指南</a>，我们制作主题一般是选用CDN的方式。SDK和Leancloud数据存储的初始化大致代码请见ylion主题的<a href="https://github.com/GeekaholicLin/hexo-theme-ylion/blob/master/layout/_partial/_head-sections/script.ejs#L7-L19" target="_blank" rel="noopener">相关代码</a>，制作主题阶段可以打开调试日志</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'debug'</span>, <span class="string">'leancloud*'</span>);</span><br></pre></td></tr></table></figure><p>但在应用发布的时候，删掉该行代码，即可关闭调试日志，以免暴露敏感信息。<strong>如果删掉之后，在本地还是会显示的，这时请再清空Local Storage对应的数据即可。</strong></p><div class="figure"><img src="http://image.geekaholic.cn/acecz5kpij00o4y6kpe9u43a5h" alt="删掉该行即可"><p class="caption">删掉该行即可</p></div><p>初始化leancloud之后，接下来就是逻辑部分的代码了。但在逻辑部分开始前，让我们先明确几个leancloud需要用到的概念，为了更好的理解，从数据库的角度进行类比，但是这是不严谨的。</p><ul><li><p>应用：为了方便管理不同的应用或者网站或者程序等。不同的应用对应着不同的数据库。</p></li><li><p>Class: 在官方的说法中，Class是AV.Object的一个实例。个人认为Class对应着数据库中的表，用来存储信息，表与表之间也是可以进行“交互”的。在创建应用的时候，leancloud会为我们初始化一些表，比如<code>_User</code>、<code>_Role</code>等，在我们的主题中并不需要用到，就不展开讲了，如果你的应用需要用到这几个Class，还希望自己翻阅文档，leancloud的文档还算比较清晰的了。</p></li><li><p>属性：对应数据表中的列。</p></li></ul><div class="figure"><img src="http://image.geekaholic.cn/2phdciysyieupd75ou6yzup8lq" alt="leancloud后台界面"><p class="caption">leancloud后台界面</p></div><h4 id="创建class">创建Class</h4><p>在<code>创建新的应用</code>后，在<code>存储</code>的菜单，选择<code>创建Class</code>，Class名字自己取，但是要在主题中的配置文件中添加(ylion主题自动把其挂载到全局对象中，方便获取)，以<code>BlogCounter</code>为例子，并选择<code>无限制</code>。(这种方式有风险，后面会讲到如何控制)，点击<code>创建Class</code>即可。</p><p>其实在后台初始化地建立列是可以的，但是会显得麻烦，我们把它移到我们的代码中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newcounter = <span class="keyword">new</span> Counter();</span><br><span class="line">newcounter.set(<span class="string">"title"</span>, title);</span><br><span class="line">newcounter.set(<span class="string">"url"</span>, url);</span><br><span class="line">newcounter.set(<span class="string">"times"</span>, <span class="number">1</span>);</span><br><span class="line">newcounter.save(<span class="literal">null</span>, &#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">newcounter</span>) </span>&#123;&#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params">newcounter, error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Failed to create!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这里创建了<code>title</code>、<code>url</code>、<code>times</code>3个属性列，并设置其中的值为未有阅读量文章的相关信息。</p><p>说回安全控制，可使用如图所示的方法，这也是官方推荐使用的方法，这样就确保在一定域名下才能访问你的敏感数据。</p><div class="figure"><img src="http://image.geekaholic.cn/bmsz65rvvaryxq9mlgdxuvu4hi" alt="添加安全域名"><p class="caption">添加安全域名</p></div><h4 id="统计阅读量">统计阅读量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLength; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(className);</span><br><span class="line">    <span class="keyword">var</span> item = <span class="literal">null</span>,</span><br><span class="line">    url = <span class="string">""</span>;</span><br><span class="line">    item = $targetArr[index];</span><br><span class="line">    url = item.getAttribute(<span class="string">'data-leadcloud-url'</span>);</span><br><span class="line">    query.equalTo(<span class="string">"url"</span>, url);</span><br><span class="line">    query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (results.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> counter = results[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> times = counter.get(<span class="string">"times"</span>);</span><br><span class="line">        item.innerHTML = times.toString().trim();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        item.innerHTML = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(i);</span><br></pre></td></tr></table></figure><p>这里使用遍历是因为在归档页面有多个文章需要查询阅读量。核心代码解释如下：</p><ul><li><p><code>var query = new AV.Query(className);</code> 新建一个<a href="https://leancloud.github.io/javascript-sdk/docs/AV.Query.html" target="_blank" rel="noopener">Query对象</a>，而className为你在leancloud后台新建应用的<code>Class对象</code>。</p></li><li><p><code>query.equalTo(&quot;url&quot;, url);</code>为查询条件设置。在ylion主题中，以文章的url比如<code>/2017/02/22/制作Hexo主题详细教程（1）/</code>作为查询条件。更多的查询方式和逻辑运算请看<a href="https://leancloud.github.io/javascript-sdk/docs/AV.Query.html" target="_blank" rel="noopener">官方文档相关内容</a></p></li><li><p><code>var times = counter.get(&quot;times&quot;);</code>获取<code>Class对象</code>中的<code>times</code>列，并赋值。</p></li></ul><h4 id="热门文章">热门文章</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(className);</span><br><span class="line">query.descending(<span class="string">"times"</span>);</span><br><span class="line">query.limit(limits);</span><br><span class="line">query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">  length = results.length; i &lt; length; i++) &#123; (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> item = results[index];</span><br><span class="line">      title = item.get(<span class="string">'title'</span>) || <span class="string">'No Title!'</span>;</span><br><span class="line">      url = item.get(<span class="string">'url'</span>);</span><br><span class="line">      times = item.get(<span class="string">'times'</span>);</span><br><span class="line">      $result += <span class="string">'&lt;li class="popular-item popular-item-'</span> + (index + <span class="number">1</span>) + <span class="string">'"&gt;'</span>;</span><br><span class="line">      $result += <span class="string">'&lt;a href="'</span> + url + <span class="string">'"&gt;'</span> + title + <span class="string">'&lt;sup&gt;'</span> + times + <span class="string">'&lt;/sup&gt;&lt;/a&gt;'</span>;</span><br><span class="line">      $result += <span class="string">'&lt;/li&gt;'</span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  $popularContent.innerHTML = $result;</span><br></pre></td></tr></table></figure><p>如果理解了上面的查询过程，那么热门文章的获取也就很好理解了。先是获取Query对象，再对<code>times</code>进行降序，再选取<code>limits</code>篇文章，将其进行字符串拼接，最后更新<code>innerHTML</code>。</p><p>在这里只是对部分代码进行讲解，如果你想看完整代码，<a href="https://github.com/GeekaholicLin/hexo-theme-ylion/blob/master/source/js/app.js#L319-#L406" target="_blank" rel="noopener">Here</a>，之后的地址和代码可能会进行更改，而且我相信你会写出更加优美的代码而不是复制粘贴。</p><p>leancloud的集成还特别感谢“<a href="http://crescentmoon.info/2014/12/11/popular-widget/" target="_blank" rel="noopener">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件</a>”该篇文章。</p><h2 id="更强的自定义">更强的自定义</h2><p>在上一篇文章中，讲到有好多目录，其中有一个<code>scripts</code>目录，这个目录和<code>source</code>目录下的<code>js</code>目录是<strong>不同</strong>的，前者是在部署之前的脚本，后者是部署之后，前端使用的脚本文件。在官方的<a href="https://hexo.io/zh-cn/api/" target="_blank" rel="noopener">API</a>中的拓展有很多，比如<code>Console</code>、<code>Filter</code>、<code>Generator</code>和<code>Helper</code>等。本人接触的不多，只能将自己的见解写下来，如果有错误，还望指出~</p><p>在我个人的理解看来，Helper是为了代码的模块化和复用代码块而存在，Generator为了生成所需文件而存在，Filter是为了改变原先的文件内容而存在。除了写过Helper以及改写过<code>hexo-generator-search</code>外(因为该插件并不提供标签和分类搜索，已提交了<a href="https://github.com/GeekaholicLin/hexo-generator-search/pull/1" target="_blank" rel="noopener">pr</a>)，其余的尚未接触过，就不误人子弟了。</p><p>很多人可能会问了，在前端模版引擎中照样可以写逻辑处理，为什么不那样？</p><p>其实可以是可以，但是当逻辑过于复杂或者代码量过大，写在ejs文件里面不利于复用和维护，就像内嵌的JavaScript一样。在前面的文章讲到，Hexo为我们提供了很多的辅助器，而这辅助器和<code>scripts</code>目录下的脚本文件一样的性质，只不过接口不同，代码的编写不同，但是大同小异，因为都是用的JavaScript。</p><h3 id="hexo自带的辅助函数">Hexo自带的辅助函数</h3><p>是不是觉得Hexo提供给我们的辅助函数很好用？或者，你想根据自己的主题需要，想在原来的辅助函数上进行修改？</p><p>首先我们得找到文件所在，在博客目录下的<code>/node_modules/hexo/lib/plugins/helper</code>目录中，可以找到与Hexo自带的辅助函数同名文件。比如<code>&lt;%- js(path, ...) %&gt;</code>辅助函数对应<code>js.js</code>文件，其他的一般也是如此(但是<code>is_home</code>等都在<code>is.js</code>文件中)，<code>js.js</code>的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsHelper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> path = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    path = <span class="built_in">arguments</span>[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i) result += <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(path)) &#123;</span><br><span class="line">      result += jsHelper.apply(<span class="keyword">this</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.substring(path.length - <span class="number">3</span>, path.length) !== <span class="string">'.js'</span>) path += <span class="string">'.js'</span>;</span><br><span class="line">      result += <span class="string">'&lt;script src="'</span> + <span class="keyword">this</span>.url_for(path) + <span class="string">'"&gt;&lt;/script&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = jsHelper;</span><br></pre></td></tr></table></figure><p>这样就可以在原本的基础上，根据自己的需求进行修改了<sup>-</sup></p><p>在ylion主题中，<a href="https://github.com/GeekaholicLin/hexo-theme-ylion/blob/master/scripts/helper/my_paginator.js" target="_blank" rel="noopener">my_paginator.js</a>文件就是在自己的需求上进行修改。原本的分页器在首页会隐藏“上一页”的按钮以及在末页会隐藏“下一页”的按钮，觉得不美观，就进行了更改，只让其不可点击，而不是隐藏。</p><p>至于自定义Helper的使用方法，也是和自带的Helper使用方法一样<code>&lt;%- my_paginator()%&gt;</code>。</p><h3 id="如何编写hexo-helper">如何编写Hexo Helper</h3><p>但是在原本基础进行修改并不能解决所有的情况，比如提取post文件中的图片地址，比如让文章支持top置顶功能。在这里以<code>文章支持top置顶功能为例</code>。置顶功能查看过很多博文，都是提倡使用修改Hexo的排序算法。我在写ylion主题的时候也查看过Next主题的相应的源代码，但是看不懂…所以就决定根据<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">该博文</a>的排序算法，自己写一个支持置顶功能的Helper。（Update: 该方法有个bug，文章页的上一篇和下一篇还是会是以时间为序，待解决）</p><p>先说大概的思路：</p><ol style="list-style-type: decimal"><li>对全部的文章进行排序</li><li>问题还没解决。原本的Hexo分页是按照日期进行的，当点击下一页的时候，出现的文章还是原先的排序，而我们需要的是展示自己的排序，所以我们还需要改变一下遍历的变量。</li><li>我们可以根据第一步排好的顺序，再根据当前页数，每页的文章数目就可以<code>slice</code>对应部分赋值给<code>curPosts</code>，并对其进行遍历，而不仅仅遍历<code>page.posts</code>。</li></ol><p>先是实现了排序功能的Helper</p><figure class="highlight javascript"><figcaption><span>sortPosts</span><a href="https://github.com/GeekaholicLin/hexo-theme-ylion/blob/master/scripts/helper/sortPosts.js" target="_blank" rel="noopener">sortPosts.js</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortPostsFunc</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> datas = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.top &amp;&amp; b.top) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">      <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> datas;</span><br><span class="line">&#125;</span><br><span class="line">hexo.extend.helper.register(<span class="string">'sortPosts'</span>, sortPostsFunc);</span><br></pre></td></tr></table></figure><p><code>hexo.extend.helper.register('sortPosts', sortPostsFunc);</code>是核心部分，就像<code>nodejs</code>暴露接口一样，<code>sortPosts</code>为提供ejs文件使用的Helper名字，而<code>sortPostFunc</code>为Helper的逻辑处理函数，而参数<code>posts</code>则是在使用的使用所用到的,也就是实参是<code>site.posts</code></p><p>而<code>curPosts</code>变量的获取使用了<code>getCurPosts</code>这个Helper，代码比较简短，相信大家可以看得懂，就不详细说明了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurPosts</span>(<span class="params">sortedPosts, config, page</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sortedPosts.slice((page.current - <span class="number">1</span>) * config.per_page, page.current * config.per_page);</span><br><span class="line">&#125;</span><br><span class="line">hexo.extend.helper.register(<span class="string">"getCurPosts"</span>,getCurPosts);</span><br></pre></td></tr></table></figure><p>可以发觉，实现一个Helper并没有什么难度，也是考察JavaScript的编写能力。两个Helper的使用方法可以查看<a href="https://github.com/GeekaholicLin/hexo-theme-ylion/blob/master/layout/index.ejs#L5-L8" target="_blank" rel="noopener">这部分代码</a></p><p>制作Hexo主题详细教程系列基本上算是完结了。而<a href="/2017/02/22/制作Hexo主题详细教程（1）/">第一篇</a>说会写<code>ylion主题的小功能及其实现思路</code>。但想想，好像与主题制作无关，只能算是彩蛋部分，所以<strong>暂时移除</strong>。后面再用一篇文章专门讲讲这个方面吧~</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着&lt;a href=&quot;/2017/02/22/制作Hexo主题详细教程（1）/&quot;&gt;上一次的教程&lt;/a&gt;,还有一些细节没有讲，分别是配置文件、第三方服务、自定义辅助器、&lt;del&gt;主题的小功能&lt;/del&gt;等。&lt;/p&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;配置文件&lt;/h2&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Web/"/>
    
    
      <category term="ylion" scheme="http://blog.geekaholic.cn/tags/ylion/"/>
    
      <category term="Hexo" scheme="http://blog.geekaholic.cn/tags/Hexo/"/>
    
      <category term="主题制作" scheme="http://blog.geekaholic.cn/tags/%E4%B8%BB%E9%A2%98%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>制作Hexo主题详细教程（1）</title>
    <link href="http://blog.geekaholic.cn/2017/02/22/%E5%88%B6%E4%BD%9CHexo%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <id>http://blog.geekaholic.cn/2017/02/22/制作Hexo主题详细教程（1）/</id>
    <published>2017-02-22T14:53:00.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于">关于</h2><h3 id="为什么要造轮子">为什么要造轮子</h3><p>利用寒假接近半个月来写了一个<a href="https://github.com/GeekaholicLin/hexo-theme-ylion" target="_blank" rel="noopener">主题</a>。为什么要造轮子？其实做这个Hexo主题的目的就是想学习更高级的用法，比如<code>less</code>，比如<code>ejs</code>，比如<code>CSS3</code>以及原生<code>JavaScript</code>，也为了更好地沉淀。因为大半年的时间学习jQuery，处理IE的兼容，感觉越来越与前端的发展脱节…</p><h3 id="为什么要写本教程">为什么要写本教程</h3><p>在写ylion主题的时候，我也没想到会是如此艰辛。艰辛的不是技术使用方面，艰辛的是<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>。当你写过主题就知道官方的API写的多么的含糊不清(摔！)，而要命的是，这方面的介绍少之又少(也可能是我搜索的姿势不对…)。所以，为了方便后来造轮子者有个参考，也为了温习制作主题时利用到的知识，写下本教程，本教程以ylion主题为例，<strong>水平有限，如有纰漏，还望指出~</strong></p><h3 id="准备">准备</h3><p>制作一款Hexo主题的要求并不高，要求掌握<code>ejs</code>、<code>less</code>、以及基本的<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>，还有熟悉Hexo提供的插件和功能(参见API文档)。至于设计方面的知识，可以参考现有的主题，包括但不限于Hexo主题。</p><p><code>ejs</code>和<code>less</code>可以使用<code>Swig</code>和<code>Sass/Scss</code>等，要看自己熟悉哪一个，自己用的适应就行。</p><p><code>ejs</code>和<code>less</code>并不难学，两者都是为了模块化，减少代码量。前者基本上是js+html，后者基本是css。而<code>JavaScript</code>部分，如果想减少上手难度，可以使用<code>jQuery</code>代替。</p><h2 id="开始">开始</h2><h3 id="初始化">初始化</h3><p>按照<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">教程</a>配置好自己的开发环境，然后<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">初始化</a>，Hexo则会在指定目录新建需要的文件。 该目录下的文件说明，可以在<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">官方文档</a>中看到，不再赘述。</p><h3 id="新建主题">新建主题</h3><p>在<code>themes</code>建立新的文件夹，命名为<code>ylion</code>，为了减少工作量，这里使用<code>generator-hexo-theme</code>和<code>yo</code>来帮我们自动生成需要的目录和文件，再根据我们的需求进行删减和添加。当然，手动建立也是可以的。</p><p>首先是需要工具的安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install yo -g</span><br><span class="line">  npm install generator-hexo-theme -g</span><br></pre></td></tr></table></figure><p>然后在新建的<code>ylion</code>目录，使用命令<code>yo hexo-theme</code>，进行技术栈的选择。结束后大概是以下的画面：</p><div class="figure"><img src="http://image.geekaholic.cn/qm1k5oy4o3bdh2n07mdj0lq505" alt="hexo-theme"><p class="caption">hexo-theme</p></div><p>而现在的<code>ylion</code>目录下的结构为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── layout</span><br><span class="line">│   ├── archive.ejs</span><br><span class="line">│   ├── category.ejs</span><br><span class="line">│   ├── index.ejs</span><br><span class="line">│   ├── layout.ejs</span><br><span class="line">│   ├── page.ejs</span><br><span class="line">│   ├── partials</span><br><span class="line">│   │   ├── pagination.ejs</span><br><span class="line">│   │   └── recent-posts.ejs</span><br><span class="line">│   ├── post.ejs</span><br><span class="line">│   └── tag.ejs</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── css</span><br><span class="line">    │   └── ylion.less</span><br><span class="line">    ├── favicon.ico</span><br><span class="line">    └── js</span><br><span class="line">        └── ylion.js</span><br></pre></td></tr></table></figure><p>经过删减和增加后的文件结构一般如下,至于该新建什么文件，是根据自己的主题进行的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── _config.yml <span class="comment">### 主题的配置文件</span></span><br><span class="line">├── languages <span class="comment">### 多语言支持目录</span></span><br><span class="line">│   ├── default.yml</span><br><span class="line">│   ├── zh-CN.yml</span><br><span class="line">│   └── zh-TW.yml</span><br><span class="line">├── layout <span class="comment">### 布局模块目录</span></span><br><span class="line">│   ├── _partial <span class="comment">### 可重复利用的模块目录</span></span><br><span class="line">│   ├── _thirdParty <span class="comment">### 第三方模块目录</span></span><br><span class="line">│   ├── _widget <span class="comment">### 小插件模块目录</span></span><br><span class="line">│   ├── archive.ejs <span class="comment">### 归档布局文件</span></span><br><span class="line">│   ├── category.ejs <span class="comment">### 分类布局文件</span></span><br><span class="line">│   ├── index.ejs <span class="comment">### 首页布局文件</span></span><br><span class="line">│   ├── layout.ejs <span class="comment">### 主布局文件</span></span><br><span class="line">│   ├── page.ejs <span class="comment">### 分页导航布局文件</span></span><br><span class="line">│   ├── post.ejs <span class="comment">### 文章详情文件</span></span><br><span class="line">│   └── tag.ejs <span class="comment">### 标签布局文件</span></span><br><span class="line">├── package.json</span><br><span class="line">├── scripts <span class="comment">###</span></span><br><span class="line">│   ├── generator <span class="comment">### 生成器</span></span><br><span class="line">│   └── helper <span class="comment">### 辅助器</span></span><br><span class="line">└── <span class="built_in">source</span> <span class="comment">###</span></span><br><span class="line">    ├── css <span class="comment">### css</span></span><br><span class="line">    ├── favicon.ico <span class="comment">### 网站图标</span></span><br><span class="line">    ├── fonts <span class="comment">### 字体</span></span><br><span class="line">    ├── img <span class="comment">## 图片目录</span></span><br><span class="line">    └── js <span class="comment">## js</span></span><br></pre></td></tr></table></figure><p>至于每个目录和文件有什么作用，为什么这么分，以及如何自己更强地自定义，会在下面的内容或者以后的内容讲到。</p><h3 id="文档补充">文档补充</h3><p>这一部分是对Hexo官方文档的烂的一比的部分(主要表现在<code>自定义</code>部分)进行的补充说明，以及编写主题时的一些心得。我会尽量对照着官方文档的顺序进行补充。</p><h4 id="模板">模板</h4><p>在官方的<a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模板说明文档</a>页面，有这么一个表格。让我们回头看<code>ylion</code>目录下的部分文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">│   ├── archive.ejs <span class="comment">### 归档布局文件</span></span><br><span class="line">│   ├── category.ejs <span class="comment">### 分类布局文件</span></span><br><span class="line">│   ├── index.ejs <span class="comment">### 首页布局文件</span></span><br><span class="line">│   ├── layout.ejs <span class="comment">### 主布局文件</span></span><br><span class="line">│   ├── page.ejs <span class="comment">### 分页导航布局文件</span></span><br><span class="line">│   ├── post.ejs <span class="comment">### 文章详情文件</span></span><br><span class="line">│   └── tag.ejs <span class="comment">### 标签布局文件</span></span><br></pre></td></tr></table></figure><p>再对照表格：</p><div class="figure"><img src="http://image.geekaholic.cn/1snknxi1kcjzgsgojrpazsh92e" alt="模板表格"><p class="caption">模板表格</p></div><p>其中<code>layout.ejs</code>是最主要的文件，它是所有布局的入口，而其他的布局(layout)比如<code>index.ejs</code>只是<code>layout.ejs</code>的<code>&lt;%- body %&gt;</code>部分。</p><p>当你访问博客的首页时，通过表格知道首页对照的模板为<code>index.ejs</code>，这时Hexo将<code>index.ejs</code>的内容替换掉<code>layout.ejs</code>中的<code>&lt;%- body %&gt;</code>。而如果是归档界面呢？对的，是<code>archive.ejs</code>的内容替换掉<code>&lt;%- body %&gt;</code>。而如果<code>archive.ejs</code>不存在呢？这时就该表格中的<code>回调</code>部分出场了，<code>archive.ejs</code>的回调是<code>index.ejs</code>，则说明当<code>archive.ejs</code>不存在的时候，用<code>index.ejs</code>的内容。</p><p>那问题来了，如果我想添加新的页面(page)怎么办？其实有好多种方法。</p><ol style="list-style-type: decimal"><li><p>Github Pages有一个功能，是每个项目都可以算是一个page。比如你的repo名字是<code>demo</code>，而你的Github名字是<code>Geek</code>，也就是说你的个人域名是<code>geek.github.io</code>，那你可以通过<code>geek.github.io/demo/index.html</code>访问<code>demo</code>repo下的<code>index.html</code>，是不是很方便，这样就可以建立很多个pages了。</p></li><li><p>但是，我们不想那么麻烦怎么办？根据一定的网站知识，我们可以知道，在你博客目录下的<code>source</code>目录下建立一个<code>demo</code>目录，然后添加<code>index.html</code>照样可以实现上述的功能。</p></li><li><p>但是又有一个问题，这个<code>index.html</code>没有样式，脚本等等，你想让Hexo帮你渲染，怎么弄？ <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">'demo'</span></span><br></pre></td></tr></table></figure></p></li></ol><p>则会帮你完成在<code>source</code>目录创立<code>demo</code>目录，并初始化一个<code>index.md</code>文件，使用的渲染布局自然就是<code>page.ejs</code>了，为什么？<a href="https://hexo.io/zh-cn/docs/commands.html#new" target="_blank" rel="noopener">官方命令说明</a>如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p><p>但这还不够，因为比如会添加许多许多pages。<code>page.ejs</code>如何加以区分，然后进行渲染？ 这时候<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">front-matter</a>出场了。给它加上一个字段<code>type: 'demo'</code>，然后在<code>page.ejs</code>进行逻辑判断，获取的变量为<code>page.type</code>，然后实现你的业务逻辑即可。目前(2017-2-22)ylion主题尚未实现<code>page.ejs</code>渲染分类等。</p><ol start="4" style="list-style-type: decimal"><li>又有一个问题(问题真多…)，如果我不想用<code>page.ejs</code>进行渲染呢，毕竟在一个文件里写过多的<code>page.type</code>判断会显得乱，可不可以单独一个文件，比如<code>demo.ejs</code>进行渲染。当然可以！更改<code>demo</code>目录下的<code>index.md</code>文件的<code>front-matter</code>中的<code>layout</code>字段，为你要渲染的layout名字，此处为<code>demo</code>，然后在<code>layout</code>文件夹下新建一个文件<code>demo.ejs</code>即可~这相当于<strong>自定义layout</strong>。</li></ol><p>至于<code>Partial</code>局部模块，还是要根据自己的需求进行处理。比如<code>ylion</code>主题中的<code>article-meta</code>是文章的信息显示。因为在ylion主题的每个页面都有出现，这时候就有必要抽取为一个局部模块，减少代码的代码量。</p><p>而优化是不能够缺少的，如果你的主题是提交至官方Hexo的话。<strong>在这里有一个坑！！！</strong>一般来说，局部缓存的代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&apos;_partial/xxxxx&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt;</span><br></pre></td></tr></table></figure><p>但是，如果你<code>xxxx</code>局部模块中的变量是根据不同页面被赋不同的值，则不能够使用，不然所有页面中的<strong>此变量都是同一个值</strong>,切记。</p><h4 id="变量">变量</h4><p>全局变量，官方已经讲的很清楚了，不再赘述，主要讲页面变量。</p><p>不过，还是举一个例子。以ylion主题中的<code>leancloud</code>统计功能为例子，如果在ejs文件中想获取主题下的<code>_config.yml</code>的设置，可以使用<code>theme.leancloud.enable</code>进行判断。至于怎么正确获取配置中的值，还请熟悉配置文件的格式。之后会有教程专门讲解，不是这部分的内容。</p><div class="figure"><img src="http://image.geekaholic.cn/aknwxmpru3ss9hnubjv1kte4ll" alt="全局变量"><p class="caption">全局变量</p></div><p><strong>注意：</strong>全局变量中的<code>page</code>指的是<code>页面变量</code>，与页面变量中的<code>page</code>是不同的。页面变量到底有哪些内容，是根据当前不同的布局(layout)而决定的。</p><p>比如页面变量中的<code>page</code>是指由<code>page.ejs</code>渲染的页面，<code>post</code>是<code>post.ejs</code>渲染的页面。就这么简单？Too Young!!</p><p>让我们来看看文档又给我们挖了什么样的坑。页面变量中的<code>page</code>变量说的就是你。</p><div class="figure"><img src="http://image.geekaholic.cn/f10e1zorltdtbmkqp4aepvs940" alt="page 变量"><p class="caption">page 变量</p></div><p><code>page</code>变量有一部分是<strong>front-matter 所设定的变量</strong>，而不是它本身拥有的。比如<code>page.photos</code>，其他的暂时没有验证，<strong>目测</strong> <code>page.link</code>也是。想当时，一直郁闷为什么无法获取文章的照片，原来是需要在文章中指定（摔！）</p><p>似乎理清了变量怎么使用，但有些人会对<code>page.layout</code>变量感到郁闷，我也是在写这篇文章的时候才搞懂。算是临时加上的吧。<code>page.layout</code>对应<code>page.ejs</code>来说肯定是<code>page</code>，对于<code>post.ejs</code>来说肯定是<code>post</code>，这毋庸置疑。但问题来了。对于<code>hexo new page 'demo'</code>的<code>demo page</code>来说，layout也是<code>page</code>，其他的新建页面同理，但是有没有办法改变？</p><p>办法是有的，但是改变的话’意思’就完全变了。</p><p><a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">front-matter</a>变量中有一个<code>layout</code>字段，官方文档在该页并没有详细讲解。<code>layout</code>字段指定的是该page使用哪一个layout进行渲染。由前面的模板部分讲解的4种方法创建一个page中的’自定义布局一样’。所以，<strong>页面变量中的page变量指的是page布局和自定义布局的对象变量更加准确</strong>。</p><h4 id="辅助函数">辅助函数</h4><p>这一部分倒不是有什么问题，而是我有话想说。关于制作Hexo主题的一点小经验。</p><p>ylion主题的制作过程中，我是先花了将近两天完成了基本的原型，期间参考了很多博客的设计，完成了HTML和基本的CSS部分。在写原型的时候，有意地进行模块划分，这样有利于后期转换为ejs和less更加方便。这样好处是有的，不用在多个文件来来回回地跳，这样很容易混乱。但坏处是什么？</p><p>坏处就是，你写的结构和类名与Hexo官方提供的辅助函数生成的结构和类名不同，这就会导致你要改类名，严重的需要修改整个结构。当然，修改Hexo官方的辅助函数是可以的，以后的教程会讲到如何做，但是这样又增加了工作量，得不偿失。</p><p>所以，折中或者理智的做法应该是，看官方的辅助函数为你生成的结构和类名是什么，这类辅助函数集中在<a href="https://hexo.io/zh-cn/docs/helpers.html#列表" target="_blank" rel="noopener">列表</a>和<a href="https://hexo.io/zh-cn/docs/helpers.html#paginator" target="_blank" rel="noopener">分页器</a>，所以在写主题前最好了解一下。举个栗子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result += &apos;&lt;li class=&quot;&apos; + className + &apos;-list-item&apos; + additionalClassName + &apos;&quot;&gt;&apos;;</span><br><span class="line"></span><br><span class="line">      result += &apos;&lt;a class=&quot;&apos; + className + &apos;-list-link&apos; + (isCurrent ? &apos; current&apos; : &apos;&apos;) + &apos;&quot; href=&quot;&apos; + self.url_for(cat.path) + &apos;&quot;&gt;&apos;;</span><br><span class="line">      result += transform ? transform(cat.name) : cat.name;</span><br><span class="line">      result += &apos;&lt;/a&gt;&apos;;</span><br><span class="line"></span><br><span class="line">      if (showCount) &#123;</span><br><span class="line">        result += &apos;&lt;span class=&quot;&apos; + className + &apos;-list-count&quot;&gt;&apos; + cat.length + &apos;&lt;/span&gt;&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (child) &#123;</span><br><span class="line">        result += &apos;&lt;ul class=&quot;&apos; + className + &apos;-list-child&quot;&gt;&apos; + child + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      result += &apos;&lt;/li&gt;&apos;;</span><br></pre></td></tr></table></figure><p>这是<code>list_categories</code>辅助函数的一部分内容，生成的是文章的分类列表，如果你的结构不是这样，不就需要进行修改了吗？</p><p>官方的补充说明暂且就这么多吧。</p><h2 id="未完待续">未完待续</h2><p>因为文章过长，所以分割为两个部分进行，前一个部分也就是本文，主要讲如何开始和补充那坑爹的Hexo文档。对应着<code>ylion</code>目录的文件，已经算是讲解了</p><ol style="list-style-type: decimal"><li><code>languages</code>多语言支持(官方文档)。</li><li><code>layout</code>布局，讲了如何新建page，如何自定义layout，讲了如何看到官方文档的模板表格以及优化的注意事项。</li><li>变量的补充说明。</li></ol><p>还剩下实现的一些细节:</p><ol style="list-style-type: decimal"><li>如何写<code>_config.yml</code>文件以及如何读取其中的变量</li><li>如何集成第三方服务</li><li>如何改写和自定义辅助器或者生成器等</li><li><del>ylion主题的小功能及其实现思路</del></li></ol><p>To be continued…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于&quot;&gt;关于&lt;/h2&gt;
&lt;h3 id=&quot;为什么要造轮子&quot;&gt;为什么要造轮子&lt;/h3&gt;
&lt;p&gt;利用寒假接近半个月来写了一个&lt;a href=&quot;https://github.com/GeekaholicLin/hexo-theme-ylion&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Web/"/>
    
    
      <category term="ylion" scheme="http://blog.geekaholic.cn/tags/ylion/"/>
    
      <category term="Hexo" scheme="http://blog.geekaholic.cn/tags/Hexo/"/>
    
      <category term="主题制作" scheme="http://blog.geekaholic.cn/tags/%E4%B8%BB%E9%A2%98%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>mathjax</title>
    <link href="http://blog.geekaholic.cn/2017/02/19/mathjax/"/>
    <id>http://blog.geekaholic.cn/2017/02/19/mathjax/</id>
    <published>2017-02-19T14:51:32.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是一个测试mathjax公式的页面">这是一个测试mathjax公式的页面</h2><blockquote><p>例子参考来自<a href="https://zh.wikipedia.org/wiki/Help:%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">wikipedia</a> [请自备梯子]</p></blockquote><p><strong>说明：</strong> 主题是否要支持Mathjax，其实思考了挺久的。因为在Hexo下的默认markdown渲染会与 Mathjax的渲染冲突，而其他大部分的渲染并不如此。为了和其他的Markdown渲染引擎兼容， <a href="http://shomy.top/2016/10/22/hexo-markdown-mathjax/" target="_blank" rel="noopener">需要做一些工作</a>。</p><p><del>如果是其他主题迁移到本主题，或者将以前在其他地方的文章放在本主题，为了更大的兼容性和减少工作量，还请使用上述链接中的<a href="http://shomy.top/2016/10/22/hexo-markdown-mathjax/#修改hexo渲染源码" target="_blank" rel="noopener">修改Hexo渲染源码</a>。</del></p><p><del>如果是第一次在本主题编写的Latex，还请做出一些妥协。为了通用性和减少工作量，你可以使用修改Hexo渲染源码的方法，但这本人并不推荐。 本主题参考<a href="http://gohugo.io/tutorials/mathjax/" target="_blank" rel="noopener">该网址</a>的做法，使用<code>&lt;div&gt;&lt;/div&gt;</code>包裹<code>Displayed Equation</code>，使用 <code>&lt;code&gt;</code>标签的点符号包含 <code>Inline Equation</code>，比如 ‘<span class="math inline">\(inline Equation\)</span>’（此处为了演示，使用了单引号）</del></p><p>因为各种原因，还请各位自己参考<a href="http://shomy.top/2016/10/22/hexo-markdown-mathjax/" target="_blank" rel="noopener">上述链接</a>，自行寻找适合自己的解决方案。</p><p>本测试文件使用<code>hexo-renderer-pandoc</code>插件进行Markdown文件渲染。</p><h3 id="函数符号及特殊字符">函数、符号及特殊字符</h3><h4 id="声调变音符号">声调/变音符号</h4><p><span class="math display">\[\acute{a} \grave{a} \hat{a} \tilde{a} \breve{a}\\\check{a} \bar{a} \ddot{a} \dot{a}\]</span></p><h4 id="标准函数">标准函数</h4><p><span class="math display">\[\sin a \cos b \tan c\\\sec d \csc e \cot f\\\arcsin h \arccos i \arctan j\\\sinh k \cosh l \tanh m \coth n\!\\\operatorname{arsinh}r\,\operatorname{arcosh}s\,\operatorname{artanh}t\\\lim u \limsup v \liminf w \min x \max y\!\\\inf z \sup a \exp b \ln c \lg d \log e \log_{10} f \ker g\!\\\deg h \gcd i \Pr j \det k \hom l \arg m \dim n\]</span></p><h4 id="模代数">模代数</h4><p><span class="math inline">\(s_k \equiv 0 \pmod{m}\)</span>` `$ a,,b $</p><h4 id="微分">微分</h4><p><span class="math inline">\(\nabla \, \partial x \, \mathrm{d}x \, \dot x \, \ddot y\, \mathrm{d}y/\mathrm{d}x\, \frac{\mathrm{d}y}{\mathrm{d}x}\, \frac{\partial^2 y}{\partial x_1\,\partial x_2}\)</span></p><h4 id="分数矩阵和多行列式">分数、矩阵和多行列式</h4><p><span class="math display">\[\frac{2}{4}=0.5\]</span> <span class="math display">\[\tfrac{2}{4} = 0.5\]</span> <span class="math display">\[\cfrac{2}{c + \cfrac{2}{d + \cfrac{2}{4}}} = a\]</span> <span class="math display">\[\dfrac{2}{4} = 0.5 \qquad \dfrac{2}{c + \dfrac{2}{d + \dfrac{2}{4}}} = a\]</span> <span class="math display">\[\dbinom{n}{r}=\binom{n}{n-r}=\mathrm{C}_n^r=\mathrm{C}_n^{n-r}\]</span> <span class="math display">\[\tbinom{n}{r}=\tbinom{n}{n-r}=\mathrm{C}_n^r=\mathrm{C}_n^{n-r}\]</span> <span class="math display">\[\binom{n}{r}=\dbinom{n}{n-r}=\mathrm{C}_n^r=\mathrm{C}_n^{n-r}\]</span> <span class="math display">\[\begin{Bmatrix}x &amp; y \\z &amp; v\end{Bmatrix}\]</span> <span class="math display">\[f(n) =\begin{cases}n/2,  &amp; \mbox{if }n\mbox{ is even} \\3n+1, &amp; \mbox{if }n\mbox{ is odd}\end{cases}\]</span> <span class="math display">\[\begin{alignat}{3}f(x) &amp; = (m-n)^2 \\f(x) &amp; = (-m+n)^2 \\&amp; = m^2-2mn+n^2 \\\end{alignat}\]</span> <span class="math display">\[\begin{cases}3x + 5y +  z \\7x - 2y + 4z \\-6x + 3y + 2z\end{cases}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这是一个测试mathjax公式的页面&quot;&gt;这是一个测试mathjax公式的页面&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;例子参考来自&lt;a href=&quot;https://zh.wikipedia.org/wiki/Help:%E6%95%B0%E5%AD%A6%E5%
      
    
    </summary>
    
      <category term="编程之外" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
      <category term="Hexo" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/Hexo/"/>
    
    
      <category term="Hexo主题" scheme="http://blog.geekaholic.cn/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
      <category term="ylion" scheme="http://blog.geekaholic.cn/tags/ylion/"/>
    
      <category term="Mathjax" scheme="http://blog.geekaholic.cn/tags/Mathjax/"/>
    
  </entry>
  
  <entry>
    <title>pandoc-markdown测试文件</title>
    <link href="http://blog.geekaholic.cn/2017/02/19/pandoc-markdown%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.geekaholic.cn/2017/02/19/pandoc-markdown测试文件/</id>
    <published>2017-02-19T14:51:32.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明：</strong> 本文件使用<code>hexo-renderer-pandoc</code>插件进行基于Hexo官方Markdown测试文件渲染，以验证pandoc-markdown语法是否兼容hexo-markdown语法。</p><hr><h1 id="基本元素测试">基本元素测试</h1><p>The purpose of this post is to help you make sure all of HTML elements can display properly. If you use CSS reset, don’t forget to redefine the style by yourself.</p><hr><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Heading 1</span><br><span class="line"></span><br><span class="line">## Heading 2</span><br><span class="line"></span><br><span class="line">### Heading 3</span><br><span class="line"></span><br><span class="line">#### Heading 4</span><br><span class="line"></span><br><span class="line">##### Heading 5</span><br><span class="line"></span><br><span class="line">###### Heading 6</span><br></pre></td></tr></table></figure><h1 id="heading-1">Heading 1</h1><h2 id="heading-2">Heading 2</h2><h3 id="heading-3">Heading 3</h3><h4 id="heading-4">Heading 4</h4><h5 id="heading-5">Heading 5</h5><h6 id="heading-6">Heading 6</h6><hr><h2 id="paragraph">Paragraph</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, [test link]() consectetur adipiscing elit. **Strong text** pellentesque ligula commodo viverra vehicula. *Italic text* at ullamcorper enim. Morbi a euismod nibh. &lt;u&gt;Underline text&lt;/u&gt; non elit nisl. ~~Deleted text~~ tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.</span><br><span class="line"></span><br><span class="line">Interdum et malesuada fames ac ante ipsum primis in faucibus. `Sed erat diam`, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.</span><br><span class="line"></span><br><span class="line">&gt; Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</span><br><span class="line"></span><br><span class="line">Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.</span><br></pre></td></tr></table></figure><p>Lorem ipsum dolor sit amet, <a href>test link</a> consectetur adipiscing elit. <strong>Strong text</strong> pellentesque ligula commodo viverra vehicula. <em>Italic text</em> at ullamcorper enim. Morbi a euismod nibh. <u>Underline text</u> non elit nisl. <del>Deleted text</del> tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.</p><p>Interdum et malesuada fames ac ante ipsum primis in faucibus. <code>Sed erat diam</code>, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.</p><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><p>Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.</p><h2 id="list-types">List Types</h2><h3 id="definition-list-dl">Definition List (dl)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;&lt;dt&gt;Definition List Title&lt;/dt&gt;&lt;dd&gt;This is a definition list division.&lt;/dd&gt;&lt;/dl&gt;</span><br></pre></td></tr></table></figure><dl><dt>Definition List Title</dt><dd>This is a definition list division.</dd></dl><h3 id="ordered-list-ol">Ordered List (ol)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. List Item 1</span><br><span class="line">2. List Item 2</span><br><span class="line">3. List Item 3</span><br></pre></td></tr></table></figure><ol style="list-style-type: decimal"><li>List Item 1</li><li>List Item 2</li><li>List Item 3</li></ol><h3 id="unordered-list-ul">Unordered List (ul)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- List Item 1</span><br><span class="line">- List Item 2</span><br><span class="line">- List Item 3</span><br></pre></td></tr></table></figure><ul><li>List Item 1</li><li>List Item 2</li><li>List Item 3</li></ul><h2 id="table">Table</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Table Header 1 | Table Header 2 | Table Header 3 |</span><br><span class="line">| - | - | - |</span><br><span class="line">| Division 1 | Division 2 | Division 3 |</span><br><span class="line">| Division 1 | Division 2 | Division 3 |</span><br><span class="line">| Division 1 | Division 2 | Division 3 |</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>Table Header 1</th><th>Table Header 2</th><th>Table Header 3</th></tr></thead><tbody><tr class="odd"><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr class="even"><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr class="odd"><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table><h2 id="misc-stuff---abbr-acronym-sub-sup-etc.">Misc Stuff - abbr, acronym, sub, sup, etc.</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem &lt;sup&gt;superscript&lt;/sup&gt; dolor &lt;sub&gt;subscript&lt;/sub&gt; amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. &lt;cite&gt;cite&lt;/cite&gt;. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. &lt;acronym title=&quot;National Basketball Association&quot;&gt;NBA&lt;/acronym&gt; Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.  &lt;abbr title=&quot;Avenue&quot;&gt;AVE&lt;/abbr&gt;</span><br></pre></td></tr></table></figure><p>Lorem <sup>superscript</sup> dolor <sub>subscript</sub> amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. <cite>cite</cite>. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. <acronym title="National Basketball Association">NBA</acronym> Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. <abbr title="Avenue">AVE</abbr></p><h1 id="标签测试">标签测试</h1><p>This post is used for testing tag plugins. See <a href="http://zespia.tw/hexo/docs/tag-plugins.html" target="_blank" rel="noopener">docs</a> for more info.</p><h2 id="block-quote">Block Quote</h2><h3 id="normal-blockquote">Normal blockquote</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</span><br></pre></td></tr></table></figure><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><h3 id="quote-from-a-book">Quote from a book</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="quote-from-twitter">Quote from Twitter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;</span><br><span class="line">NEW: DevDocs now comes with syntax highlighting. http://devdocs.io</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote>NEW: DevDocs now comes with syntax highlighting. http://devdocs.io<footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="noopener">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="quote-from-an-article-on-the-web">Quote from an article on the web</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote>Every interaction is both precious and an opportunity to delight.<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="code-block">Code Block</h2><h3 id="normal-code-block">Normal code block</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure><h3 id="with-caption">With caption</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock Array.map %&#125;</span><br><span class="line">array.map(callback[, thisArg])</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="with-caption-and-url">With caption and URL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock .compact http://underscorejs.org/#compact Underscore.js %&#125;</span><br><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h3 id="with-marked-lines">With marked lines</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 1,7-8,10 should be marked with different color.</span><br><span class="line"></span><br><span class="line">&#123;% codeblock lang:js mark:1,7-8,10 %&#125;</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">const hostname = &apos;127.0.0.1&apos;;</span><br><span class="line">const port = 1337;</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br><span class="line">  res.end(&apos;Hello World\n&apos;);</span><br><span class="line">&#125;).listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);</span><br><span class="line">&#125;);</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line"></span><br><span class="line">Note: Theme&apos;s style should support `.highlight.line.marked` (recommend to use the selection or current line color).</span><br></pre></td></tr></table></figure><p>Line 1,7-8,10 should be marked with different color.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line marked"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line marked">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line marked">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(port, hostname, () =&gt; &#123;</span><br><span class="line marked">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Note: Theme’s style should support <code>.highlight.line.marked</code> (recommend to use the selection or current line color).</p><h3 id="gist">Gist</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% gist 996818 %&#125;</span><br></pre></td></tr></table></figure><script src="//gist.github.com/996818.js"></script><h3 id="jsfiddle">jsFiddle</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% jsfiddle ccWP7 %&#125;</span><br></pre></td></tr></table></figure><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" allowfullscreen></iframe><h2 id="pullquote">Pullquote</h2><h3 id="left">Left</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% pullquote left %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span><br><span class="line">&#123;% endpullquote %&#125;</span><br><span class="line"></span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</span><br></pre></td></tr></table></figure><blockquote class="pullquote left">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</p><h3 id="right">Right</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% pullquote right %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span><br><span class="line">&#123;% endpullquote %&#125;</span><br><span class="line"></span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</span><br></pre></td></tr></table></figure><blockquote class="pullquote right">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</p><h1 id="总结">总结</h1><p>有几点是需要注意的：</p><ol style="list-style-type: decimal"><li>标题前面一定要有空行。</li><li>分割线<code>---</code>前后都要有空行</li><li>其余的语法暂时没有发现有什么问题，更多拓展语法请参考<a href="http://www.bagualu.net/wordpress/archives/5284" target="_blank" rel="noopener">markdown语法及pandoc扩展</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 本文件使用&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;插件进行基于Hexo官方Markdown测试文件渲染，以验证pandoc-markdown语法是否兼容hexo-markdown语法。&lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
      <category term="编程之外" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
      <category term="Hexo" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/Hexo/"/>
    
    
      <category term="Hexo主题" scheme="http://blog.geekaholic.cn/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
      <category term="ylion" scheme="http://blog.geekaholic.cn/tags/ylion/"/>
    
      <category term="Mathjax" scheme="http://blog.geekaholic.cn/tags/Mathjax/"/>
    
  </entry>
  
  <entry>
    <title>Genymotion模拟器无法启动解决办法</title>
    <link href="http://blog.geekaholic.cn/2016/03/18/Genymotion%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://blog.geekaholic.cn/2016/03/18/Genymotion模拟器无法启动解决办法/</id>
    <published>2016-03-18T20:44:36.000Z</published>
    <updated>2019-09-26T05:21:46.903Z</updated>
    
    <content type="html"><![CDATA[<p>Genymotion模拟器可谓是Android开发者最常用的模拟器之一，拥有启动速度快，有Android Studio IDE 的插件。但有时候启动Genymotion模拟器的时候会遇到错误。</p><p>不同的错误有不同的解决方法。不保证可以解决相同类型的错误，因为同种类型错误可以由多种不同的原因造成。但是如果遇到无法启动时，以下方法值得一试~</p><p>大概情况是，在启动Genymotion模拟器的时候，会发生错误。错误如下图所示：</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-18_00003.jpg" alt="错误情况"><p class="caption">错误情况</p></div><p>解决无法打开GM的办法之一如下。来自<code>stackoverflow</code>，原链接没有保存到(T-T)只保留住其中一个答案，以便笔记</p><blockquote><p>I have a same problem and I solve it with this :</p></blockquote><pre><code>Open Windows Network ConnectionsRight click on VirtualBox Host only adapter that createdChoose propertiesCheck &quot;VirtualBox NDIS6 Bridged Networking driver&quot;disable and Enable the adapter</code></pre><p>在<code>网络和共享中心</code>中找到VisualBox的适配器。 <img src="http://old-image.geekaholic.cn/jm.jpg" alt="步骤1"></p><p><strong>右键</strong>，然后<strong>属性</strong>。</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-18_00002.jpg" alt="步骤2"><p class="caption">步骤2</p></div><p>勾上图中的选项，并且点击<strong>确定</strong>按钮退出。</p><p>再次启动Genymotion模拟器即可，完美解决。</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-18_00004.jpg" alt="模拟器界面"><p class="caption">模拟器界面</p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Genymotion模拟器可谓是Android开发者最常用的模拟器之一，拥有启动速度快，有Android Studio IDE 的插件。但有时候启动Genymotion模拟器的时候会遇到错误。&lt;/p&gt;
&lt;p&gt;不同的错误有不同的解决方法。不保证可以解决相同类型的错误，因为同种
      
    
    </summary>
    
      <category term="编程之外" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
      <category term="解决方法" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Android" scheme="http://blog.geekaholic.cn/tags/Android/"/>
    
      <category term="解决方法" scheme="http://blog.geekaholic.cn/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    
      <category term="Genymotion" scheme="http://blog.geekaholic.cn/tags/Genymotion/"/>
    
      <category term="VisualBox" scheme="http://blog.geekaholic.cn/tags/VisualBox/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记--CSS设计指南(理论部分)</title>
    <link href="http://blog.geekaholic.cn/2016/03/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--CSS%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97(%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86)/"/>
    <id>http://blog.geekaholic.cn/2016/03/11/读书笔记--CSS设计指南(理论部分)/</id>
    <published>2016-03-11T23:36:41.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面">说在前面</h2><blockquote><p>如果你看到这部分内容竟然和《css设计指南》的如此相似，不要惊讶，因为这个是我在看书时的笔记，权当是查漏补缺和加强自己的理论知识。当然，不是全书地照搬，还会增加个人的理解，还有一些很好的文章。比如<code>@font-face</code>的使用，找了很多不错的参考文章，作为对书中的补充。 如果你和我是从初级阶段，当过几次切图仔(本人目前还是)，想进阶到更高一个级别，那这部分内容你不容错过。因为在你使用的时候并不注意，一些坑坑洼洼会让你烦恼很久。如果你是大神级别，还不吝你能指出错误，感激不尽~</p></blockquote><p>此部分为<a href="https://book.douban.com/subject/23123255/" target="_blank" rel="noopener">CSS设计指南(第3版)</a>读书笔记的理论部分(<strong>个人认为</strong>)，除开第5章部分，第6章全章，第7章全章。</p><h2 id="知识点大杂烩">知识点大杂烩</h2><h3 id="那些坑儿">那些坑儿</h3><ol style="list-style-type: decimal"><li><p>不设置宽度的块级元素盒子会扩展到与父元素同宽</p></li><li><p>有一点很重要，那就是 CSS 样式是通过<code>&lt;style&gt;</code>标签嵌入到页面里的。当浏览器遇到 开标签<code>&lt;style&gt;</code>时，就会由解释 HTML 代码切换为解释 CSS 代码。等遇到闭标签<code>&lt;/style&gt;</code>时，它会再切换回解释 HTML 代码</p></li><li><p>紧邻同胞选择符+,一般同胞选择符~</p></li><li><p>一个冒号（:）表示伪类，两个冒号（::）表示 CSS3 新增的伪元素。尽管浏览器目前都支持对 CSS 1 和 CSS 2的伪元素使用一个冒号，但希望你能习惯于用双冒号代替单冒号，因为这些单冒号的伪元素最终可能都会被淘汰掉。<sub><del>更多相关信息，可以参见这里：传送门</del></sub></p></li><li><p>通过在上下文选择符中使用链接伪类，可以轻易地为 nav、 footer、 aside 和article元素中的链接应用不同的外观和行为。[技巧一]</p></li><li><p>link伪类四个同时使用的时候 ：为了好记，我建议大家可以这 么想：“ LoVe? HA!”大写字母就是每个伪类的头一个字母。【顺序问题困扰很久】</p></li><li><p>新学习的伪类，<strong><code>:target</code></strong></p></li></ol><blockquote><p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标target），可以用:target 伪类选中它。 对于下面这个链接<code>&lt;a href=&quot;#more_info&quot;&gt;More Information&lt;/a&gt;</code>位于页面其他地方、 ID 为more_info 的那个元素就是目标。该元素可能是这样的：<code>&lt;h2 id=&quot;more_info&quot;&gt;This is the information you are looking for.&lt;/h2&gt;</code> 那么，如下CSS规则 <code>#more_info:target{background:#eee;}</code> 会在用户单击链接转向ID为more_info的元素时，为该元素添加浅灰色背景。</p></blockquote><ol start="8" style="list-style-type: decimal"><li><code>:nth-child</code> 伪类最常用于提高表格的可读性，比如对表格的所有行交替应用不同颜色。</li></ol><blockquote><p><code>e:nth-child(n)</code>,括号里的n为第n个元素e元素</p></blockquote><ol start="9" style="list-style-type: decimal"><li><p><code>font-variant</code>： 属性设置小型大写字母的字体显示文本</p></li><li>p::first-line {font-variant:small-caps;}` 可以把第一行以小型大写字母显示。</li><li><p><code>::first-line</code>为伪元素。伪元素就是你的文档中<strong>若有实无</strong>的元素。类似的还有<code>::first-letter</code>，可以设置第一个字的样式.<code>::before</code>和<code>::after</code>伪元素。</p></li></ol><p>“first-line”，“first-letter” 伪元素只能用于块级元素。</p><blockquote><p><strong>搜索引擎不会取得伪元素的信息（因为它在标记中并不存在）。因此,不要通过伪元素添加你想让搜索引擎索引的重要内容</strong>。</p></blockquote><ol start="11" style="list-style-type: decimal"><li>color 是前景色，前景色既影响文本，也影响边框。但人们通常只用它设定文本颜色。</li><li>要改变背景图片的起点，可以修改 background-position 属性。</li><li><p>只给 background-position 设定一个关键字值，则另一个也会取相同的值。 &gt; /<em>center center 的简化写法</em>/ p#center {background-position:center;}</p></li><li><code>background-position:center center</code>设定<strong>图片中心点与元素中心点重合</strong>，然后再向各个方向重复。</li><li><p>由14可知，通过把<code>background-position</code>设定为 <code>50% 50%</code>，把 <code>background-repeat</code>设定为<code>no-repeat</code>，实现了图片在背景区域内居中的效果。</p></li><li><p><code>background-size</code>为我们控制背景图片提供了更多可能性。</p></li></ol><p><sub><del>17. <code>font-size</code>,<code>height</code>,<code>line-height</code>三者的关系是：<code>height</code>将盒子撑开，<code>line-height</code>是从文本的<strong>基线</strong>处在文本行上下平均分配，<strong>不影响标准文档流</strong>，<code>font-size</code>是在从文本的<strong>基线</strong>处开始变大，会撑开盒子模型，但可以显示在其他元素上方。丝毫不影响标准文档流。不信可以在Chrome中将<code>font-size</code>调大进行观察</del></sub>。(update:尚未熟悉) 18. 使用 Modernizr来检测浏览器对它们的支持情况，并为不支持它们的浏览器提供替代 CSS。</p><blockquote><p>Modernizr 是一个 JavaScript 库，用于检测用户浏览器支持哪些 HTML5 和 CSS3 功能。 更多信息，请参考这个网址： <a href="http://modernizr.com" class="uri" target="_blank" rel="noopener">http://modernizr.com</a></p></blockquote><ol start="19" style="list-style-type: decimal"><li><p>默认情况下，背景绘制区域是扩展到边框外边界的。 &gt; 如果想使用更多的选择，使用CSS3中的<code>background-clip</code>属性。提供3个可选值。 background-clip: border-box;/<em>背景包括border</em>/ background-clip: padding-box;/<em>背景包括padding，不包括border</em>/ background-clip: content-box;/<em>背景包括content，不包括padding和border</em>/</p></li><li><p><code>font-family</code> 用于设定元素中的文本使用什么字体。一般来说，应该给整个页面设定一种主字体，然后只对那些需要使用不同字体的元素再应用 <code>font-family</code>。要为整个页面指定字体，可以设定 body 元素的 <code>font-family</code> 属性。<code>font-family</code>是可以继承的属性，因此它的值会遗传给所有后代元素。</p></li><li><p>小技巧:我们永远也不敢保证一定能用某种字体来显示网页。为此，在指定文本的字体时，需要多列出几种后备字体，以防第一种字体无效。这个字体的列表也叫<strong>字体栈</strong>。</p></li><li><p>西方国家字母体系分为两类：<code>serif</code>以及<code>sans serif</code>。<code>serif</code>是有衬线字体,在每个字符笔画的末端会有一些装饰线。 <code>sans-serif</code>，也就是无衬线字体，字符笔画的末端没有装饰线。具体看下图。</p></li></ol><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-14_00001.jpg" alt="字体"><p class="caption">字体</p></div><ol start="23" style="list-style-type: decimal"><li>字体大小</li></ol><blockquote><p>默认情况下， 1em等于 16 像素，这也是 font-size 的基准大小。如果需要重新设定了基准大小，则修改body 的字体大小。body的字体大小即为1em(比如重新设定为20px,则1em = 20px)</p></blockquote><ul><li><p>绝对字体大小。 优点：它们是绝对单位，因此设定多大就多大，与祖先元素的字体大小无关。 缺点：<strong>使用绝对单位的缺点很明显，那就是在需要调整页面所有元素的字体大小时，必须一个一个地修改样式表中的 font-size</strong>。</p></li><li><p>相对字体大小。如果你给某个元素设定了相对字体大小，则该元素的字体大小要相对于<strong>最近的“被设定过字体大小的”祖先元素</strong>来确定。 优点：使用相对大小后，通过调整body元素的字体大小，可以成比例地改变所有元素的字体大小。或者，至少能通过改变某个祖先元素，只影响它的所有子元素。 缺点：“牵一发而动全身”的事，出现连锁反应，所以使用相对字体大小时，必须事先规划好。 【请看下面例子】</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;This is &lt;strong&gt;very important!&lt;/strong&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">p &#123;font-size:.<span class="number">75</span>em;&#125;</span><br><span class="line">strong &#123;font-size:.<span class="number">75</span>em;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算</span></span><br><span class="line"></span><br><span class="line">font-size(p) = <span class="number">0.75</span>*<span class="number">16</span>px = <span class="number">12</span>px;</span><br><span class="line">font-size(strong) = <span class="number">12</span>px * <span class="number">0.75</span> = <span class="number">9</span>px;</span><br></pre></td></tr></table></figure><ol start="24" style="list-style-type: decimal"><li><p>默认值并不是无用，它可以用来有选择地覆盖某个默认或你设定的全局属性。</p></li><li><p>由于浏览器对数字值的实现各不相同，所以从常规字体到粗体的切换可能发生在不同的数值上——通常是 400左右。总之，对于 font-weight 属性来说，最好只用 <code>bold</code> 和 <code>normal</code>这两个值。</p></li></ol><p><strong>26</strong>. 粗体和斜体：两个都有两种方法，一种是标签来控制显示，一种是用css来控制。</p><ul><li>斜体：<code>font-style:italic;</code>或<code>font-style:oblique;</code>或<code>&lt;em&gt;</code> (emphasized)标签或<code>&lt;i&gt;</code>(italic)标签。</li><li>粗体: <code>font-weight:bold;</code>或<code>&lt;strong&gt;</code>(strong)标签或<code>&lt;b&gt;</code>(bold)标签。</li></ul><p><strong>那应该如何选择？</strong></p><blockquote><p>其实，个人认为，如果不是特别强调的，不要轻易使用<code>&lt;em&gt;</code>,<code>&lt;strong&gt;</code>两种分别显示斜体和粗体。因为他们在搜索引擎中更受重视，将会影响SEO。也就是说，在一般情况下，使用css来控制字体样式(推荐)或者<code>&lt;b&gt;</code>和<code>&lt;i&gt;</code>。</p></blockquote><ol start="27" style="list-style-type: decimal"><li><strong>text-indent的那些坑</strong> 【坑1】 <code>text-indent</code> 是可以被子元素继承的。如果你在一个 <code>div</code> 上设定了 <code>text-indent</code> 属性，那么 <code>div</code> 中的所有段落都会继承该缩进值。然而，与 所有继承的 CSS 值一样，<strong>这个缩进值并不是祖先元素中设定的值，而是计算的值</strong>。(注意)【请看下面例子】</li></ol><blockquote><p>假设有一个 400 像素宽的 div，包含的文本缩进 5%，则缩进的距离是 20 像素（400 的 5%）。 在这个 div 中有一个 200 像素宽的段落。作为子元素，它继承父元素的 <code>text-indent</code>值，所以 它包含的文本也缩进。但继承的缩进值是多少呢？不是 5%，而是 20 像素。也就是说，子元素 继承的是根据父元素宽度计算得到的缩进值。结果，虽然段落只有父元素一半宽，但其中的文 本也会缩进 20 像素。这样可以确保无论段落多宽，它们的缩进距离都一样。当然，在子元素 上重新设定 text-indent 属性，可以覆盖继承的值</p></blockquote><p>【坑2】</p><blockquote><p>一个容易疏忽的点，就是，<code>text-indent</code>对于块级文本元素有效，比如<code>&lt;p&gt;</code>，<code>&lt;li&gt;</code>。如果一个段落很长，则只会对首行缩进，要实现每行都缩进，可以使用多个<code>&lt;p&gt;</code>，或者<code>margin-left</code>属性(看需求)。</p></blockquote><p>【坑3】</p><blockquote><p>在设定缩进和外边距时<strong>最好同时使用em</strong>，以便在改变字体大小时， 它们的长度能够按比例变化。</p></blockquote><ol start="28" style="list-style-type: decimal"><li>文本修饰的一些建议。</li></ol><blockquote><ul><li>blink 是为文本添加闪烁效果的，实际上很讨厌，应该少用，最好不用。</li><li>上网的人都习惯了把带下划线的文本当成链接。如果你给本来不是链接的文本加上下划线，很容易导致困惑和无效点击。</li><li>利用下划线的出现和隐藏，呈现有效的视觉反馈。</li></ul></blockquote><ol start="29" style="list-style-type: decimal"><li>间距的那些事儿~</li></ol><blockquote><ul><li><code>letter-spacing</code>对英文字母、汉字及其他字符都起作用。<code>etter-spacing</code> 的值是在浏览器默认值<strong>基础上增加或减少</strong>的值。</li></ul></blockquote><blockquote><ul><li>纯汉字文本一段之中没有空格，因此<code>word-spacing</code>对中文网页几乎没有用，但对中英混排段落可能有用。【见下图】</li></ul></blockquote><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-14_00002.jpg" alt="中文word-spacing"><p class="caption">中文word-spacing</p></div><ol start="30" style="list-style-type: decimal"><li>自定义字体库@font-face(css3属性，IE9+才支持)</li></ol><p>使用@font-face 规则在网页中嵌入可下载字体的 CSS 功能，为设计师提供了系统自带字体以外的广泛选择，不必再依赖用户机器中的字体。有3种使用方法。</p><ol style="list-style-type: decimal"><li>使用 <a href="https://www.google.com/fonts/" target="_blank" rel="noopener">Google Web Fonts</a> 或 Adobe 的 Typekit 等公共字体库。</li><li>使用事先打好包的@font-face 包。</li><li>使用 <a href="http://www.fontsquirrel.com" target="_blank" rel="noopener">Font Squirrel</a> 用你自己的字体生成@font-face 包</li></ol><blockquote><p>小缺陷: 使用@font-face的一个问题是不同浏览器要求的字体格式不一样。比如， Firefox、Webkit 核心的浏览器（Safari 和Chrome），以及 iOS 4.1 版之后的移动Safari使用OTF（OpenType）或TTF（TrueType）字体。 Internet Explorer 使用 EOT（Embedded OpenType）。另外， iOS 4.1 之前版本中的移动 Safari 以及其他浏览器使用 SVG（Scalable Vector Graphics）格式。</p></blockquote><p>讲那么多很难描述清楚，书中也是忽略而过。看下面的链接，已经讲得够详细。但需要提醒的是，在定义好自己的<code>font-family</code>之后，<strong>在css中的选择器上使用才可以显示效果</strong>。</p><blockquote><p><a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="noopener">传送门</a></p></blockquote><h3 id="继承">继承</h3><p>CSS 中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多CSS属性不能继承，因为<strong>继承这些属性没有意义</strong>。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距。【继承对自身有意义的属性】</p><p>举个例子吧，假设我们想创建一个边栏，在其中放一组链接。为此，我们用 nav 元素嵌套该组链接，并给nav应用了一种字号和一个边框效果，比如 2 像素宽的红色边框。不难想象，nav中的所有链接都继承它的字号正常，可要是也继承它的边框就不合适了。当然，这些链接不会继承边框效果，因为 border 属性不能继承。</p><h3 id="层叠">层叠</h3><p>层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。这就涉及到了优先级。 优先级的大概计算如下<a href="http://liunian.info/css-specificity.html" target="_blank" rel="noopener">通俗易懂</a> 如果优先级的值一样，则以后者为先。</p><h3 id="样式缩写">样式缩写</h3><p>如果哪个值没有写，那就使用对边的值。 E.G. <code>{margin:12px 10px 6px;}</code> 对这个例子来说，由于没有写最后一个值（左边的值），所以左边就会使用右边的值。</p><blockquote><p>叠加的只是垂直外边距，水平外边距不叠加。对于水平相邻的元素，它们的水平间距是相邻外边距之和。</p></blockquote><h2 id="盒子模型加强">盒子模型（加强）</h2><h3 id="盒子模型两大结论">盒子模型两大结论</h3><blockquote><p>盒模型结论一：没有（就是没有设置width的）宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。[<strong>其实也可以看成是结论二的特殊情况，因为最大宽度被父级宽度所限制，不会再增加</strong>]</p></blockquote><blockquote><p>盒模型结论二：为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的width属性设定的只是<strong>盒子内容区的宽度</strong>，而非盒子要占据的水平宽度。 （<strong>补充：宽度高度都适用</strong>。） 这两种盒子所表现出来的完全不同的行为，对将来构建多栏布局具有重要的启示。因为在多栏布局中，每一栏都必须时刻维护自己的宽度. CSS3 新增了一个 <code>box-sizing</code> 属性，通过它可以将有宽度的盒子也设定成具有默认的auto状态下的行为。【IE8+支持】 具体是怎么一回事？<a href="http://www.w3school.com.cn/cssref/pr_box-sizing.asp" target="_blank" rel="noopener">box-sizing</a></p></blockquote><p><code>box-sizing</code>的默认值是<code>content-box</code>，也就是上面的两个结论。 <code>box-sizing</code>的另外一个值，是CSS3的内容，<code>border-box</code>。就是将结论1的特性应用到结论2，无论是否有设定具体的高度和宽度，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制，不会再增加元素的宽度和高度。</p><h3 id="两大结论的好处">两大结论的好处</h3><p>这两个结论有什么用？</p><blockquote><p>在三栏布局的时候，最外层<strong>固定宽度</strong>，要在不改变盒子的宽度的前提下，需要增加外层和内容间的间距，如果使用内边距<code>padding</code>则会增加盒子的宽度。(见盒子模型结论2)。一个好的办法是使用<code>box-sizing:border-box;</code>，还可以增加一个<code>div</code>，不设置宽度。但考虑到那两个神一般存在的浏览器(IE6,IE7)，还是推荐使用方法2–增加一个<code>div</code>，不设置宽度【虽然方法1可以用JS的方式来实现，使用borderBoxModel.js】</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- HTML 标记 --&gt;</span><br><span class="line">&lt;!-- 只让 IE8 之前的 IE 加载它 --&gt;</span><br><span class="line">&lt;!--[if lt IE 8 ]&gt;</span><br><span class="line">&lt;script src=&quot;helpers/borderBoxModel.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>但使用JS的方式有所局限，比如，宽高必须使用px作为单位。不支持<code>onresize, min/max-width等不固定属性</code>，如果布局复杂，还需要更多的测试来保证布局没有被破坏。<a href="https://github.com/albertogasparin/borderBoxModel" target="_blank" rel="noopener">具体可以看这个github项目</a></p><h3 id="盒子模型的一些坑">盒子模型的一些坑</h3><p>盒子模型中还有一个巨坑。<a href="http://www.cnblogs.com/pomoho/p/4381753.html" target="_blank" rel="noopener">坑在这~</a></p><p>简单一句话（引自:《css权威指南》）</p><blockquote><p>非替换元素的内边距，边框和外边距对行内元素及其生成框没有垂直效果；也就是说，他们不会影响行内框的高度。</p></blockquote><p>什么是非替换元素和可替换元素？用一句话来区别~</p><blockquote><p>可替换元素是<strong>浏览器根据元素的标签和属性，来决定元素的具体显示内容</strong>。</p></blockquote><p>比如图像，浏览器根本不知道显示的是什么图片，只知道图片的地址，并且将其显示出来。</p><p>典型的可替换元素有 <code>&lt;img&gt;</code>、 <code>&lt;object&gt;</code>、 <code>&lt;video&gt;</code> 以及 <code>&lt;textarea&gt;</code>、 <code>&lt;input&gt;</code> 。还有，<strong>使用了 CSS content 属性插入的对象被称作匿名的可替换元素</strong>，比如<code>:before</code>和<code>:after</code>伪类。</p><p>需要注意的是，非替换元素和可替换元素，与 块级元素和行内元素，没有关系，两者是对元素的不同划分方式。</p><h3 id="盒子模型和三列布局的优化">盒子模型和三列布局的优化</h3><p>这一部分来自《css设计指南》第五章。 Tip 1 &gt; 关于通配符<code>*</code>，它会导致浏览器遍历整个DOM结构去查找所有匹配的元素。但也发现这一点性能影响几乎可以忽略不计。除非页面有成千上万个元素。</p><p>这一部分还是不大同意作者所说，毕竟大家都已经习惯使用自己的重置样式表<code>reset.css</code>让自己的页面在各大浏览器尽量在间距等可控方面表现一致。况且对于大型网站而言，优化还是十分重要的。如果有时间，当然提倡根据自己的网站进行自定义。比如网站中没有使用到表格，就没有必要对表格进行消除间距。如果没有时间，<strong>使用通配符达到目的也未尝不可</strong>。</p><p>Tip 2</p><blockquote><p><code>* {box-sizing:border-box}</code></p></blockquote><p>使用通配符和CSS特性，使得页面中的盒模型就全都符合逻辑。</p><p>Tip 3 保护布局</p><blockquote><ul><li>img{max-width:100%;} –限制图片的宽度不超过其父元素</li><li>给内容包装<code>div</code>添加 <code>overflow:hidden</code> 声明,任何超出容器边界的部分剪切掉，保护布局。</li><li>给所有栏的外包装元素应用 <code>word-wrap:break-word</code> 声明,保护布局不会被 长 URL或长文本顶得支离破碎。</li></ul></blockquote><h2 id="浮动和清除浮动">浮动和清除浮动</h2><p>浮动元素<strong>脱离了常规文档流</strong>之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。</p><p>CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。后来，也成了创建多栏布局的方式。</p><p>对于<code>float:right;</code>的元素，它脱离文档流向右移动，直到它的右边框碰到包含框。如果包含框太窄，则自动向下浮动，直到有足够的空间(此时可能导致’卡住’的情况)。</p><h3 id="清除浮动的方法">清除浮动的方法</h3><p><strong>清除浮动是清除浮动对被影响元素本身的影响，而不是浮动本身</strong>。对影响的元素使用<code>clear:left;</code>是<strong>清除浮动在左边的元素对该元素的影响，不去围绕着它浮动的元素</strong>。</p><ul><li><ol style="list-style-type: decimal"><li>给父级元素添加overflow:hidden,迫使父元素包含其浮动的子元素,但对于父元素中高度超过浮动元素的其他内容，会进行截断。</li></ol></li><li><ol start="2" style="list-style-type: decimal"><li>浮动父级元素。浮动父级元素后，不管其子元素是否浮动，它都会紧紧地包围（也称收缩包裹）住子元素。</li></ol></li><li><ol start="3" style="list-style-type: decimal"><li>添加非浮动的清除元素。（注意此时父元素未浮动）</li></ol><ul><li>3.1 在(未浮动的)父元素最后一个非浮动子元素添加一个非浮动的 子元素，然后清除该子元素。常做的做法是添加一个空的<code>&lt;div&gt;</code>标签。(例子1)</li><li>3.2 利用浮动元素的<strong>下面的兄弟元素</strong>清除。（例子1中的<code>&lt;p&gt;</code>），如果浮动元素下面没有兄弟元素，则不可使用该方法。</li><li>3.3 使用<code>:after伪元素</code>。<code>:after</code>会在元素内容后面而不是元素后面插入一个伪元素，在例子2中是<strong>the footer element…</strong>后面添加一个点，而不是在<code>&lt;section&gt;</code>父级元素后面添加。但设置<code>height:0;</code>后因为没有高度，父级元素不把它包含住，所以显示是在父级元素后面添加，其实不是的。<strong>可以自己将<code>visibility:hidden</code>去掉，调整高度进行观察</strong>。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例子1--html*/</span></span><br><span class="line">&lt;section&gt;</span><br><span class="line">&lt;img src=<span class="string">"images/rubber_duck.jpg"</span>&gt;</span><br><span class="line">&lt;p&gt;It<span class="string">'s fun to float.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;div class="clear_me"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/section&gt;</span></span><br><span class="line"><span class="string">&lt;footer&gt; Here is the footer element…&lt;/footer&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*例子1--css*/</span></span><br><span class="line"><span class="string">section &#123;border:1px solid blue;&#125;</span></span><br><span class="line"><span class="string">img &#123;float:left;&#125;</span></span><br><span class="line"><span class="string">.clear_me &#123;clear:left;&#125;</span></span><br><span class="line"><span class="string">footer &#123;border:1px solid red;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*例子2--html*/</span></span><br><span class="line"><span class="string">&lt;section class="clearfix"&gt;</span></span><br><span class="line"><span class="string">&lt;img src="images/rubber_duck.jpg"&gt;</span></span><br><span class="line">&lt;p&gt;It's fun to float.&lt;/p&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;footer&gt; Here is the footer element…&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例子2--css*/</span></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">content:<span class="string">"."</span>;</span><br><span class="line">display:block;</span><br><span class="line">height:<span class="number">0</span>;</span><br><span class="line">visibility:hidden;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>在方法2和方法3中，由于包含元素一定会包围非浮动的子元素，而且清除会让这个<strong>子元素位于（清除一侧）浮动元素的下方</strong>，因此包含元素一定<strong>会包含这个子元素——以及前面的浮动元素</strong>。【特别注意这部分的描述】</p><p>且方法3.1和方法3.2不同，3.1的p元素还是会受浮动的影响，围绕在图片周围，而3.2的p元素不会受到浮动的影响，因为是p元素是块级元素，所以它<strong>在图片下面独自一行</strong>。</p><h3 id="使用哪一种">使用哪一种？</h3><p>这三种方法的使用要因地制宜。比如，不能在下拉菜单的顶级元素上应用 overflow:hidden，否则作为其子元素的下拉菜单就不会显示了。因为下拉菜单会显示在其父元素区域的外部，而这恰恰是 <code>overflow:hidden</code> 所要阻止的。再比如，不能对已经靠自动外边距居中(<code>margin:0 auto;</code>)的元素使用“浮动父元素”技术，否则它就不会再居中。而是根据浮动值浮动到左边或右边了。</p><h2 id="布局">布局</h2><p>因为文章篇幅的原因，布局就移到另外一篇文章(实战部分)进行总结。这里大概给出几种常见，并且重要的布局方式。</p><h3 id="响应式布局可变的固定布局">响应式布局(可变的固定布局)</h3><p>使用一项叫媒体查询的CSS功能，很容易检测出用户设备的屏幕大小。然后，据以提供替代或额外的CSS，可针对相应屏幕实现更加优化的体验。使用这种方式创建对设备有感知力的网站，被称为响应式设计。实际上真正的设计原则是“移动先行”，屏幕从小到大。</p><p>一种布局不能适应多种屏幕尺寸。我们需要一种能够检测屏幕大小的方法，然后相应地修改布局。简言之，就是需要让页面能够自己响应屏幕变化。</p><ul><li>需要的技术<ul><li>媒体查询：是一种CSS语法，可以根据浏览器的特性，一般是屏幕或浏览器容器宽度提供CSS 规则，将布局变为百分比或者改变html结构。</li><li>流式布局：是使用em或百分比等相对单位设定页面总体宽度，让布局能够随屏幕大小而缩放；</li><li>弹性图片：是使用相对单位确保图片再大也不会超过其容器。</li></ul></li></ul><h4 id="媒体查询">媒体查询</h4><blockquote><p>移动设备的媒体查询:http://pugetworks.com/blog/2011/04/css-media-queries-for-targetingdifferent-mobile-devices/</p></blockquote><h4 id="媒体类型">媒体类型</h4><p>常用的媒体类型如下。</p><blockquote><p>all：匹配所有设备； handled：匹配手持设备（小屏幕、单色、带宽有限）； print：匹配分页媒体或打印预览模式下的屏幕； screen：匹配彩色计算机屏幕； 其他媒体类型还有 braille（盲文点字触觉反馈设备）、 embossed（盲文分页打印机）、projection（投影仪）、 speech（语音合成器）、 tty（电话机屏幕等固定宽度字符栅格设备）和 tv（电视机）。</p></blockquote><p><strong>任意时刻浏览器窗口中只能使用一种媒体类型</strong>。</p><h4 id="媒体特性">媒体特性</h4><p>媒体特性也就是媒体某一方面的特征，一般带有 min-或 max-前缀。 常用的媒体特性如下：</p><blockquote><p>min-device-width 和 max-device-width：匹配设备屏幕的尺寸； min-width 和 max-width：匹配视口的宽度，例如浏览器窗口宽度； orientation（值为portrait(竖屏)和landscape(横屏)）：匹配设备是横屏还是竖屏。 如果想通过媒体查询来根据用户对浏览器窗口的缩放重新调整布局，应该使用 min-width 和max-width。</p></blockquote><p>还可以使用逻辑运算符 and、 not、 or 及关键字 all、 only 组合媒体类型和媒体特性。</p><blockquote><p><code>media=&quot;only screen and (max-width: 480px)&quot;</code></p></blockquote><h4 id="使用方法">使用方法</h4><blockquote><p>把 CSS 规则嵌套在了一个@media 规则中。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@media</span> <span class="function">screen <span class="title">and</span> <span class="params">(max-width:<span class="number">568</span>px)</span> </span>&#123;</span><br><span class="line">    .column &#123;<span class="keyword">float</span>:none; width:<span class="number">96</span>%; margin:<span class="number">0</span> auto;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意该@media规则是放在css文件中或者<code>&lt;style&gt;</code>标签中使用，如图：</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-15_00001.jpg" alt="@media使用"><p class="caption"><span class="citation">@media使用</span></p></div><blockquote><p>如果要通过媒体查询应用的CSS规则非常多，那么就可以考虑使用&lt;link标签的media 属性设定条件，有选择地加载独立的样式表。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;link type=<span class="string">"text/css"</span> media=<span class="string">"print"</span> href=<span class="string">"css/print_styles.css"</span> /&gt;</span><br><span class="line">&lt;link type=<span class="string">"text/css"</span> media=<span class="string">"screen and (max-width:568px)"</span></span><br><span class="line">href=<span class="string">"css/iphone_styles.css"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>断点</strong>是指区分不同宽度设备的临界点。 比如:<code>@media screen and (max-width:640px) { /*CSS 规则*/ }</code>，断点是640px。</p><blockquote><p>一个匹配的技巧是，不要去用断点一下子去匹配特定设备的屏幕宽度。而是<strong>慢慢地缩小窗口，在发现当前布局不合适的时候再确定断点</strong>，编写新的样式。可以确保一个样式在特定宽度范围内都适用。减少工作量。</p></blockquote><h4 id="viewport视口">viewport(视口)</h4><p>用<meta>标签设定视口。比如：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; maximumscale=1.0&quot; /&gt;</code>。这个<meta>标签告诉浏览器按照屏幕宽度来显示网页，不要缩小网页。</p><h3 id="流动布局">流动布局</h3><p>流动布局的大小会随用户调整浏览器窗口大小而变化。这种布局能够更好地适应大屏幕，但同时也意味着放弃对页面某些方面的控制，比如随着页面宽度变化，文本行的长度和页面元素之间的位置关系都可能变化。Amazon.com 的页面采用的就是流动中栏布局，在各栏宽度加大时通过为内容元素周围添加空白来保持内容居中，而且现在的导航条会在布局变窄到某个宽度时收缩进一个下拉菜单中，从而为内容腾出空间。</p><h3 id="弹性布局">弹性布局</h3><p>弹性布局与流动布局类似，在浏览器窗口变宽时，不仅布局变宽，而且所有内容元素的大小也会变化，让人产生一种所有东西都变大了的感觉。</p><h3 id="圣杯布局略">圣杯布局(略)</h3><h3 id="双飞翼布局略">双飞翼布局(略)</h3><h2 id="兼容性之后备代码">兼容性之后备代码</h2><h3 id="同一表现的前后顺序">同一表现的前后顺序</h3><p>已经知道的兼容属性放在前面，而部分浏览器不兼容的新属性放在后面。浏览器不支持新属性时，会自动忽略后面的新属性。而如果浏览器支持新属性，由于<code>[css的层叠][13]</code>会自动覆盖。如下面的书中举例。</p><p>IE9 之前的浏览器都不支持多背景，因此后备代码就是在多背景 声明之前简单地再加一条单背景声明，比如： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.someElement &#123;background-image:url(images/basic_image.jpg);&#125;</span><br><span class="line">.someElement &#123;background-image:</span><br><span class="line">url(images/cool_image1.jpg),</span><br><span class="line">url(images/cool_image2.jpg),</span><br><span class="line">url(images/cool_image3.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="条件注释">条件注释</h3><h4 id="ie浏览器">IE浏览器</h4><p>如果你真想单独为 <strong>IE浏览器</strong>做点什么，可以使用如下所示的条件注释来添加后备代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在为 IE8 及更低版本的 IE 加载额外的样式 --&gt;</span><br><span class="line">&lt;!--[if lte IE 8]&gt; &lt;!-- IE 条件注释 --&gt;</span><br><span class="line">&lt;link src=&quot;ie_only.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><p>lte（less than or equal to，小于等于）、 lt（less than，小于）、gte（greater than or equal to，大于等于）、 gt（greater than，大于），甚至只写一个浏览器版本号，如 IE 6。以此为不同版本的 IE 提供后备代码。</p><p><strong>注意</strong>：这种条件注释只对<strong>指定版本的IE浏览器</strong>有效，而不满足版本的IE浏览器和其他非IE浏览器都会自动忽略该条件注释。</p><h4 id="特定标签">特定标签</h4><p>不算是条件注释的一部分，但个人感觉有一定的逻辑在里面。故把这个十分有用的标签放在这一部分。 noscript 元素用来定义在脚本未被执行时的替代内容（文本）。 这个标签可被用于可识别<code>&lt;script&gt;</code>标签但无法支持其中的脚本的浏览器。用法和普通的html标签一样。</p><h3 id="腻子脚本">腻子脚本</h3><blockquote><p>腻子脚本（polyfill）指的是<strong>一段JavaScript代码</strong>，能够赋予浏览器未曾有过的功能。</p></blockquote><p><a href="https://github.com/Modernizr/%20Modernizr/wiki/HTML5-Cross-Browser-Polyfills" target="_blank" rel="noopener">一份完整的腻子脚本列表</a>，配合<a href="http://%20modernizr.com" target="_blank" rel="noopener">modernizr</a>使用效果更佳。前者负责修复，后者负责通过检查支持情况添加相应的类，便于前者操作。</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-03-18_00001.jpg" alt="Modernizr添加了大量的表明浏览器功能的类–来自adobe"><p class="caption">Modernizr添加了大量的表明浏览器功能的类–来自adobe</p></div><p>实现’古老浏览器’对HTML5和CSS3的支持的大概过程如下。</p><blockquote><ol style="list-style-type: decimal"><li><strong>Modernizr</strong>脚本能够帮你检测用户浏览器对 HTML5 和 CSS3功能的支持情况。</li><li>为顶级的<html>标签添加一组类(为 CSS 提供便利)，标明浏览器支持什么功能。</html></li><li>设定一个 JavaScript对象modernizr的属性，以便通过JavaScript 来测试这些功能。</li></ol></blockquote><p>更详细的用法见<a href="http://www.adobe.com/cn/devnet/dreamweaver/articles/using-modernizr.html" target="_blank" rel="noopener">使用Modernizr 检测HTML5和CSS3浏览器支持功能</a></p><p>以下是<a href="https://book.douban.com/subject/23123255/" target="_blank" rel="noopener">CSS设计指南(第3版)</a>列出的常见polyfill（腻子脚本）</p><ul><li><a href="http://code.google.com/p/html5shiv" target="_blank" rel="noopener">html5shiv.js</a>：让 IE8 及更低版本的 IE 识别section、 article、 nav 等 HTML5 元素。</li><li><a href="http://www.selectivizr.com" target="_blank" rel="noopener">selectivizr</a>：让 IE（6/7/8）支持::first-child 等高级 CSS 选择符。</li><li><a href="http://code.google.com/p/ie7-js" target="_blank" rel="noopener">IE9.js</a>：修复从 IE6 到 IE9 的很多 bug 和缺损功能。</li><li><a href="http://css3pie.com" target="_blank" rel="noopener">CSS3Pie</a>：让 IE6 到 IE9 支持圆角、背景渐变、边框图片、盒阴影、 RGBa 颜色等可视化的 CSS3 功能。</li><li><a href="https://github.com/scottjehl/respond" target="_blank" rel="noopener">Respond.js</a>：让旧版本浏览器支持媒体查询。</li><li><a href="http://lea.verou.me/projects" target="_blank" rel="noopener">-prefix-free</a>为需要厂商前缀的 CSS3 声明添加前缀。【这一条还是使用IDE自己添加比较好，webstorm就有某个属性全部添加的功能】</li><li><a href="https://github.com/albertogasparin/borderBoxModel" target="_blank" rel="noopener">borderBoxModel.js</a>：让 IE6 和IE7 支持 CSS3 的 box-sizing 属性。</li></ul><hr><p><strong>参考文章与书籍</strong>：</p><p><span class="citation">[Airen的博客--CSS3 @font-face]</span><a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="noopener">26</a></p><p><a href="http://liunian.info/css-specificity.html" target="_blank" rel="noopener">CSS优先级特性</a></p><p><a href="https://book.douban.com/subject/23123255/" target="_blank" rel="noopener">CSS设计指南(第3版)</a></p><p><a href="http://www.adobe.com/cn/devnet/dreamweaver/articles/using-modernizr.html" target="_blank" rel="noopener">使用Modernizr 检测HTML5和CSS3浏览器支持功能</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说在前面&quot;&gt;说在前面&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你看到这部分内容竟然和《css设计指南》的如此相似，不要惊讶，因为这个是我在看书时的笔记，权当是查漏补缺和加强自己的理论知识。当然，不是全书地照搬，还会增加个人的理解，还有一些很好的文章。比如&lt;c
      
    
    </summary>
    
      <category term="黄金屋--读书笔记" scheme="http://blog.geekaholic.cn/categories/%E9%BB%84%E9%87%91%E5%B1%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CSS设计指南" scheme="http://blog.geekaholic.cn/categories/%E9%BB%84%E9%87%91%E5%B1%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/CSS%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="兼容性" scheme="http://blog.geekaholic.cn/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
      <category term="CSS设计指南" scheme="http://blog.geekaholic.cn/tags/CSS%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/"/>
    
      <category term="读书笔记" scheme="http://blog.geekaholic.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="polyfill" scheme="http://blog.geekaholic.cn/tags/polyfill/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机英文XP系统安装中文字体(图文教程)</title>
    <link href="http://blog.geekaholic.cn/2016/02/19/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%8B%B1%E6%96%87XP%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93-%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.geekaholic.cn/2016/02/19/虚拟机英文XP系统安装中文字体-图文教程/</id>
    <published>2016-02-19T00:14:26.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote><p>此部分为记录艰辛的历程+吐槽，不喜勿喷，可跳过。</p></blockquote><p>比较严格意义上的浏览器兼容性测试，需要这么多浏览器(天啊噜！)。 &gt; <a href="https://segmentfault.com/q/1010000000365616" target="_blank" rel="noopener">传送门–浏览器兼容测试环境</a></p><blockquote><p>下面的每个环境上下文都是互斥的： * winxp + IE6 / 搜狗 / 360 * win7 + ie9（可以使用其 ie7 / ie8 兼容模式来测试 IE7 和IE8 ）/ 搜狗 / 360 / opera / firefox / chrome * win7 + ie10 * win7 或 xp + ie8 或 ie7（可忽略） * mac + safari / firefox / chrome （可忽略） * win8.1 + ie11</p></blockquote><p>每一个选项都应该是一台远程或本地的测试机器，或者是一个vmware虚拟机，装有原生对应版本浏览器的操作系统。 在学习前端的时候，浏览器的兼容器总是让人头疼。因为硬性规定，要用原生的浏览器进行测试，不可以是<strong>IE11</strong>下对<strong>IE7-9</strong>进行仿真，而且测试的时候不可以使用在线工具(<strong>测试地址要求权限，使得在线工具无权限访问</strong>)。</p><p>有人会认为没有必要，使用IETester就可以了。引用原回答的一句话，深有体会。</p><blockquote><p>最后，不要相信IE Tester，不要相信Microsoft Expression 4 Superview的交互模式的结果，我吃了N遍“IE Tester自测通过但QA用原生低版本IE测出bug”的亏。</p></blockquote><p>只好乖乖地把浏览器装上。众所周知，IE浏览器不可多装，会覆盖，只能利用虚拟机进行安装。<a href="https://dev.windows.com/en-us/microsoft-edge/tools/vms/windows/" target="_blank" rel="noopener">[微软官方镜像下载地址]</a>好家伙~虽然IE6明文不再支持，但还有IE7这个反人类的存在。<code>windows XP</code> 系统只能使用虚拟机进行安装啦。不知道为什么本人的VMware虚拟机不支持有IE浏览器的WinXP镜像，会出错。所以换成了<code>Visual Box</code>浏览器安装。安装完成(过程很简单，只需将下载的镜像解压，进行双击即可)之后，原本以为就完事了，但问题来了。</p><h3>WinXp镜像里的IE浏览器对中文网页的支持需要中文字体，而镜像里面默认是英文字体，需要光盘进行安装。</h3><a id="more"></a><p>为了测试中文网页，使得页面不乱码，只能上网找教程。利用<strong>中文关键字</strong>在网上找遍了，无非两种方法。</p><ol style="list-style-type: decimal"><li>利用光盘进行安装(吐槽:我要是有，我还用得着你说？向导就可以帮我完成了啦。。)</li><li>下载软件包。</li></ol><p>以上两种方法不行，国内提供的软件包和教程都无法解决(如果有，还望指出~)。但心中有了大概的答案，只能利用<strong>提取镜像里面的软件</strong>进行安装。中文不可以，利用蹩脚的英文，打上关键字，在Google上搜索，OK，没想到真的有。‘皇天不负有心人’(此时搜索答案已过去3小时..T_T)</p><blockquote><p><a href="http://recentsolutions.blogspot.com/2012/09/east-asian-language-pack-for-windows-xp.html" target="_blank" rel="noopener">用力戳这里~</a></p></blockquote><h2 id="英文xp系统安装中文字体">英文XP系统安装中文字体</h2><h3 id="安装前文件准备">安装前文件准备</h3><p>但国外网站再加上时间久远，这下载有时候真的很坑爹啊。利用BT种子在迅雷里下载，MD，体验的时候下载可以达到100K/S，高速体验后，为0！！！！下次要找下载工具替换迅雷才行了。没办法，作者提供的链接都无法下载。哭…只能动用万能的国内网盘搜索了，用该文件名进行搜索。在百度云里找到了。</p><blockquote><p><a href="http://pan.baidu.com/s/1pKtQBfP" target="_blank" rel="noopener">必需文件下载</a></p></blockquote><h3 id="步骤0-总体界面图">步骤0-总体界面图</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00001.jpg" alt="步骤0-总体界面图"><p class="caption">步骤0-总体界面图</p></div><h3 id="步骤1-创建共享文件夹">步骤1-创建共享文件夹</h3><h4 id="步骤1-创建共享文件夹1">步骤1-创建共享文件夹(1)</h4><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00002.jpg" alt="步骤1-创建共享文件夹(1)"><p class="caption">步骤1-创建共享文件夹(1)</p></div><h4 id="步骤1-创建共享文件夹2">步骤1-创建共享文件夹(2)</h4><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00003.jpg" alt="步骤1-创建共享文件夹(2)"><p class="caption">步骤1-创建共享文件夹(2)</p></div><h3 id="步骤2-查看共享文件夹">步骤2-查看共享文件夹</h3><h4 id="步骤2-查看共享文件夹1">步骤2-查看共享文件夹(1)</h4><div class="figure"><img src="http://old-image.geekaholic.cn/200.jpg" alt="步骤2-查看共享文件夹(1)"><p class="caption">步骤2-查看共享文件夹(1)</p></div><h4 id="步骤2-查看共享文件夹2">步骤2-查看共享文件夹(2)</h4><div class="figure"><img src="http://old-image.geekaholic.cn/251.jpg" alt="步骤2-查看共享文件夹(2)"><p class="caption">步骤2-查看共享文件夹(2)</p></div><h3 id="步骤3-虚拟机和主机的共享文件夹对比">步骤3-虚拟机和主机的共享文件夹对比</h3><div class="figure"><img src="http://old-image.geekaholic.cn/430.jpg" alt="步骤3-虚拟机和主机的共享文件夹对比"><p class="caption">步骤3-虚拟机和主机的共享文件夹对比</p></div><h3 id="步骤4-拷贝文件到共享文件夹">步骤4-拷贝文件到共享文件夹</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00006.jpg" alt="步骤4-拷贝文件到共享文件夹"><p class="caption">步骤4-拷贝文件到共享文件夹</p></div><h3 id="步骤5-进入控制面板">步骤5-进入控制面板</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00007.jpg" alt="步骤5-进入控制面板"><p class="caption">步骤5-进入控制面板</p></div><h3 id="步骤6-进入语言和地区设置">步骤6-进入语言和地区设置</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00008.jpg" alt="步骤6-进入语言和地区设置"><p class="caption">步骤6-进入语言和地区设置</p></div><h3 id="步骤7-勾选选项2进行安装">步骤7-勾选选项2进行安装</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00009.jpg" alt="步骤7-勾选选项2进行安装"><p class="caption">步骤7-勾选选项2进行安装</p></div><h3 id="步骤8-选择安装">步骤8-选择安装</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00010.jpg" alt="步骤8-选择安装"><p class="caption">步骤8-选择安装</p></div><h3 id="步骤9-选择共享文件夹中的文件">步骤9-选择共享文件夹中的文件</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-18_00011.jpg" alt="步骤9-选择共享文件夹中的文件"><p class="caption">步骤9-选择共享文件夹中的文件</p></div><h3 id="步骤10-安装完成暂时不重启">步骤10-安装完成暂时不重启</h3><div class="figure"><img src="http://old-image.geekaholic.cn/1209.jpg" alt="步骤10-安装完成暂时不重启"><p class="caption">步骤10-安装完成暂时不重启</p></div><h3 id="步骤11-进入步骤8的面板中进行地区设置">步骤11-进入步骤8的面板中进行地区设置</h3><div class="figure"><img src="http://old-image.geekaholic.cn/1307.jpg" alt="步骤11-进入步骤8的面板中进行地区设置"><p class="caption">步骤11-进入步骤8的面板中进行地区设置</p></div><h3 id="步骤12-选择chinese和china">步骤12-选择Chinese和China</h3><div class="figure"><img src="http://old-image.geekaholic.cn/346.jpg" alt="步骤12-选择Chinese和China"><p class="caption">步骤12-选择Chinese和China</p></div><h3 id="步骤13-添加中文输入法键盘">步骤13-添加中文输入法键盘</h3><div class="figure"><img src="http://old-image.geekaholic.cn/1626.jpg" alt="步骤13-添加中文输入法键盘"><p class="caption">步骤13-添加中文输入法键盘</p></div><h3 id="步骤14-继续设置编码">步骤14-继续设置编码</h3><div class="figure"><img src="http://old-image.geekaholic.cn/1800.jpg" alt="步骤14-继续设置编码"><p class="caption">步骤14-继续设置编码</p></div><h2 id="说在最后">说在最后</h2><p>因为该虚拟系统只能使用30天，在设置好支持中文字体后，记得别忘记<strong>保存快照</strong>，这样，到时候体验到期后可以利用快照的备份进行恢复。当然，还有其他的“续期”方法，请另行百度，或者参照桌面中的英文方法。说了这么多，我会告诉你，利用官方提供的系统镜像可以通过某些方法“变相”地免费体验正版的Windows系统~？</p><blockquote><p>安装并且设置后不可用中文键盘进行中文输入，也算一个bug。目前本人尚未解决，如果有网友解决了，还请分享~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;此部分为记录艰辛的历程+吐槽，不喜勿喷，可跳过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比较严格意义上的浏览器兼容性测试，需要这么多浏览器(天啊噜！)。 &amp;gt; &lt;a href=&quot;https://segmentfault.com/q/1010000000365616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门–浏览器兼容测试环境&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面的每个环境上下文都是互斥的： * winxp + IE6 / 搜狗 / 360 * win7 + ie9（可以使用其 ie7 / ie8 兼容模式来测试 IE7 和IE8 ）/ 搜狗 / 360 / opera / firefox / chrome * win7 + ie10 * win7 或 xp + ie8 或 ie7（可忽略） * mac + safari / firefox / chrome （可忽略） * win8.1 + ie11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一个选项都应该是一台远程或本地的测试机器，或者是一个vmware虚拟机，装有原生对应版本浏览器的操作系统。 在学习前端的时候，浏览器的兼容器总是让人头疼。因为硬性规定，要用原生的浏览器进行测试，不可以是&lt;strong&gt;IE11&lt;/strong&gt;下对&lt;strong&gt;IE7-9&lt;/strong&gt;进行仿真，而且测试的时候不可以使用在线工具(&lt;strong&gt;测试地址要求权限，使得在线工具无权限访问&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;有人会认为没有必要，使用IETester就可以了。引用原回答的一句话，深有体会。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后，不要相信IE Tester，不要相信Microsoft Expression 4 Superview的交互模式的结果，我吃了N遍“IE Tester自测通过但QA用原生低版本IE测出bug”的亏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只好乖乖地把浏览器装上。众所周知，IE浏览器不可多装，会覆盖，只能利用虚拟机进行安装。&lt;a href=&quot;https://dev.windows.com/en-us/microsoft-edge/tools/vms/windows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[微软官方镜像下载地址]&lt;/a&gt;好家伙~虽然IE6明文不再支持，但还有IE7这个反人类的存在。&lt;code&gt;windows XP&lt;/code&gt; 系统只能使用虚拟机进行安装啦。不知道为什么本人的VMware虚拟机不支持有IE浏览器的WinXP镜像，会出错。所以换成了&lt;code&gt;Visual Box&lt;/code&gt;浏览器安装。安装完成(过程很简单，只需将下载的镜像解压，进行双击即可)之后，原本以为就完事了，但问题来了。&lt;/p&gt;
&lt;h3&gt;
WinXp镜像里的IE浏览器对中文网页的支持需要中文字体，而镜像里面默认是英文字体，需要光盘进行安装。
&lt;/h3&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Web" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Web/"/>
    
    
      <category term="虚拟机" scheme="http://blog.geekaholic.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="英文XP系统" scheme="http://blog.geekaholic.cn/tags/%E8%8B%B1%E6%96%87XP%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="中文字体" scheme="http://blog.geekaholic.cn/tags/%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93/"/>
    
      <category term="兼容性" scheme="http://blog.geekaholic.cn/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之线程</title>
    <link href="http://blog.geekaholic.cn/2016/02/09/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>http://blog.geekaholic.cn/2016/02/09/Java基础之线程/</id>
    <published>2016-02-09T14:56:28.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的基本概念">线程的基本概念</h2><p>线程是一个程序内部的顺序控制流。</p><h3 id="线程与进程的区别">线程与进程的区别</h3><p>每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销，线程可以看成是轻量级的进程，<strong>同一类线程共享代码和数据空间</strong>，一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。每个线程都有独立的运行栈和程序计时器，线程切换的开销小。</p><blockquote><p>多进程: 在操作系统中能同时运行多个任务(程序) 多线程: 在同一应用程序中有多个顺序流同时执行。</p></blockquote><p>进程和线程的关系初步可以理解成：进程是加载到内存里的程序，而一个进程至少拥有一个线程(Java中的Main()方法)，当然可以使用代码进行开启多线程。</p><a id="more"></a><h3 id="java中线程的知识点">Java中线程的知识点</h3><blockquote><p>JAVA的线程是通过java,lang.Thread类来实现的。 在Java中可以通过创建Thread的实例来创建新的线程。 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。 通过调用Thread类的start()方法来启动一个线程。</p></blockquote><p><strong>run()方法是执行的代码，而start()方法是开启线程，注意两者的区别</strong>。</p><h2 id="java中的线程">Java中的线程</h2><p>在Java中可以有两种方式创建新的线程。</p><h3 id="java中线程的创建方法">Java中线程的创建方法</h3><blockquote><ol style="list-style-type: decimal"><li>第一种</li></ol><ul><li>定义线程类A实现Runnable接口</li><li>实例化Runnable线程类A的对象B</li><li>实例化Thread对象: Thread mThread = new Thread(B);</li><li>实现Runnable接口中的线程运行体，也就是run()方法</li><li>使用Runnable接口的类可以为多个线程提供共享的数据。</li><li>在实现Runnable接口的类的run方法定义中可以使用Thread的静态方法。比如currntThread()方法，该方法可以获取当前线程的引用。</li></ul></blockquote><blockquote><ol start="2" style="list-style-type: decimal"><li>第二种</li></ol><ul><li>可以定义一个Thread的子类并重写run()方法</li><li>实例化Thread对象。</li></ul></blockquote><h3 id="代码示例">代码示例</h3><p><strong>方法1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnableClass mrc = <span class="keyword">new</span> MyRunnableClass();</span><br><span class="line">        Thread mThread = <span class="keyword">new</span> Thread(mrc);<span class="comment">//实际是多态的运用</span></span><br><span class="line">        mThread.start();<span class="comment">//开启线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"这是主线程中第"</span>+(i+<span class="number">1</span>)+<span class="string">"行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====开启子线程======"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"这是子线程中第"</span>+(i+<span class="number">1</span>)+<span class="string">"行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不贴出来了，两者是同时两个线程一起执行，而不是先等run()方法执行完成之后</span></span><br><span class="line"><span class="comment">//再执行main()中其他语句。因为线程的开启时间有快有慢，以及两个线程分得的</span></span><br><span class="line"><span class="comment">//时间片不一样，所以每次运行的结果有可能有区别。</span></span><br><span class="line"><span class="comment">//但当把 mThread.start(); 替换成 mThread.run(); 时，</span></span><br><span class="line"><span class="comment">//此时实际上是main()方法对run()方法进行调用，而不是开启线程执行run()方法</span></span><br></pre></td></tr></table></figure></p><p><strong>方法二</strong></p><p>与上面方法一类似，只需要适当修改一下。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnableClass mThread = <span class="keyword">new</span> MyRunnableClass();</span><br><span class="line">        mThread.start();<span class="comment">//开启线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"这是主线程中第"</span>+(i+<span class="number">1</span>)+<span class="string">"行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableClass</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====开启子线程======"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"这是子线程中第"</span>+(i+<span class="number">1</span>)+<span class="string">"行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在两个方法中，推荐使用实现接口的方法，即方法一。原因是<strong>可以实现多个接口</strong>但继承只能是单继承，不利于该类的扩展。</p><h3 id="java中线程的状态">Java中线程的状态</h3><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-09_00001.jpg" alt="Java线程的状态转换图"><p class="caption">Java线程的状态转换图</p></div><p>从图中可以看出，Java中线程大致有5中状态，在Java的API中也提供了操作Java线程的方法。让我们先睹为快。</p><blockquote><p>isAlive() 判断线程是否还未被终止。 getPriority() 获得线程的优先级数值 setPriority() 设置线程的优先级 Thread.sleep() 静态方法，将当前的线程指定毫秒数进行睡眠。会抛出interruptedException异常。 join() 调用某线程的该方法，将当前线程与该线程“合并”，即等待该线程结束，再恢复当前线程的运行。 yield() 让出cpu，当前线程进入就绪队列等待调度。 wait() 当前线程进入对象的wait pool notify()/notifyAll() 唤醒对象的wait pool中的一个/所有等待线程</p></blockquote><p>让我们使用sleep()方法实现子线程每隔1s打印出当前的时间。偷一下懒，还是使用该类，不新建其他类了。sleep()方法会抛出<code>InterruptedException</code>异常，我们需要进行捕获，关于异常的知识点在之前的博客中已经详细地讲解过了，这里不再叙述。</p><h4 id="sleepinterrupt">sleep()&amp;&amp;interrupt()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnableClass mThread = <span class="keyword">new</span> MyRunnableClass();</span><br><span class="line">        mThread.start();<span class="comment">//开启线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnableClass</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前时间"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                interrupt();<span class="comment">//粗鲁地调用方法打断当前的线程，只为演示效果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"别打断我睡觉~！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前时间Tue Feb <span class="number">09</span> <span class="number">16</span>:<span class="number">31</span>:<span class="number">03</span> CST <span class="number">2016</span></span><br><span class="line">当前时间Tue Feb <span class="number">09</span> <span class="number">16</span>:<span class="number">31</span>:<span class="number">04</span> CST <span class="number">2016</span></span><br><span class="line">别打断我睡觉~！</span><br></pre></td></tr></table></figure><h4 id="sleep与interrupt的解惑">sleep()与interrupt()的解惑</h4><p><strong>注意此处打印了两次！哎哎哎，为什么呀？不是应该只打印一次吗？那究竟interrupt()是何时作用的呢？InterruptedException是什么时候抛出的</strong>？让我们先看下面的修改版代码。</p><h4 id="sleep代码示例">sleep()代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnableClass mThread = <span class="keyword">new</span> MyRunnableClass();</span><br><span class="line">        mThread.start();<span class="comment">//开启线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnableClass</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"当前时间"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"次睡前"</span>);</span><br><span class="line">                System.out.println(<span class="string">"该线程的状态是否中断？"</span> + isInterrupted());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"次睡后"</span>);</span><br><span class="line">                System.out.println(<span class="string">"该线程的状态是否中断？"</span> + isInterrupted());</span><br><span class="line">                interrupt();<span class="comment">//调用方法打断当前的线程</span></span><br><span class="line">                System.out.println(<span class="string">"该线程的状态是否中断？"</span> + isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"异常获取到"</span>+ex);</span><br><span class="line">            System.out.println(<span class="string">"别打断我睡觉~！"</span>);</span><br><span class="line">            System.out.println(<span class="string">"该线程的状态是否中断？"</span> + isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对原来的代码进行微小的修改，运行结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前时间Tue Feb <span class="number">09</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">34</span> CST <span class="number">2016</span></span><br><span class="line">第<span class="number">1</span>次睡前</span><br><span class="line">该线程的状态是否中断？<span class="keyword">false</span></span><br><span class="line">第<span class="number">1</span>次睡后</span><br><span class="line">该线程的状态是否中断？<span class="keyword">false</span></span><br><span class="line">该线程的状态是否中断？<span class="keyword">true</span></span><br><span class="line">当前时间Tue Feb <span class="number">09</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">35</span> CST <span class="number">2016</span></span><br><span class="line">第<span class="number">2</span>次睡前</span><br><span class="line">该线程的状态是否中断？<span class="keyword">true</span></span><br><span class="line">异常获取到java.lang.InterruptedException: sleep interrupted</span><br><span class="line">别打断我睡觉~！</span><br><span class="line">该线程的状态是否中断？<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>从结果可以看到，当我们开启线程的时候，先执行打印当前时间，在之后便进入第一次睡眠(sleep)，此时的线程状态并未被打断(此时尚未执行<code>this.interrupt();</code>)(<code>isInterrupted()</code>是用来判断线程的中断状态)，当执行完<code>this.interrupt();</code>之后，线程的状态已经变成<strong>中断标志</strong>，但<strong>并非退出运行</strong>，<strong>它只是一种标识，程序还会继续执行</strong>。sleep完成之后由于是while(true)死循环，所以继续执行run()方法体的代码，再次打印时间，但当sleep()方法再次调用的时候，它抛出异常了<code>InterruptedException</code>异常，并且中断状态清除。WHY?</p><p>我在遇到这个问题的时候，也Google和百度过，但可能关键字的问题，愣是没找出来。</p><p>还是回归官网的文档吧~在IDE中双击sleep()方法，找到它的文档(已经在NetBeans中配置好文档的显示)</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-09_00003.jpg" alt="IDE截图"><p class="caption">IDE截图</p></div><blockquote><p>InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown</p></blockquote><p>这下全都明白了吧~~</p><blockquote><p>如果该线程被任何的线程所阻塞(在文档中还说明线程可被自身阻塞)，则该线程的阻塞状态会清除并抛出InterruptedException异常。</p></blockquote><p>小结一下：interrupt()可以阻塞线程自己本身，但它不是真正意义上中断该线程，只是打上<strong>中断标志</strong>，线程还会执行。当sleep()遇到interrupted为true的线程时，会清除状态为false，并抛出<code>interruptedException</code>异常。</p><p><strong>当run()方法执行结束之后，该线程也为终止状态</strong>。上面的程序修改，可以使用一个布尔型值变量来控制while循环，而不是简单粗暴的<strong>中断加异常处理</strong>。</p><h4 id="joinyield">join()&amp;&amp;yield()</h4><p>join()方法用来合并线程，相当于方法调用，等到子线程中的run()执行结束之后，main()方法中的其余部分才会继续执行。</p><p>，yiled是“退让”的意思。yield()方法让出CPU，给其他线程执行的机会。 #### join()代码示例 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunnableClass mThread1 = <span class="keyword">new</span> MyRunnableClass(<span class="string">"张三"</span>);</span><br><span class="line">         MyRunnableClass mThread2 = <span class="keyword">new</span> MyRunnableClass(<span class="string">"李四"</span>);</span><br><span class="line">         mThread1.start();</span><br><span class="line">        mThread2.start();<span class="comment">//开启线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnableClass</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    MyRunnableClass()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过super(String)为线程起名,可以使用getName()获取名字</span></span><br><span class="line">    MyRunnableClass(String name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(getName()+<span class="string">"拍"</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(getName().equals(<span class="string">"张三"</span>)&amp;&amp;i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(getName()+<span class="string">"说:每拍5次我让你一下"</span>);</span><br><span class="line">                    yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                System.out.println(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果过长，就不贴了，该代码是两人每隔1s就拍一次，每5s，张三调用了yield()方法。</p><h3 id="线程的优先级">线程的优先级</h3><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照线程的优先级决定应调度哪个线程来执行。</p><p>线程的优先级用数字来表示，范围从1~10，一个线程的缺省优先级是5.</p><blockquote><p>三个优先级常量。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>优先级越高，得到CPU调度的时间片越多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程的基本概念&quot;&gt;线程的基本概念&lt;/h2&gt;
&lt;p&gt;线程是一个程序内部的顺序控制流。&lt;/p&gt;
&lt;h3 id=&quot;线程与进程的区别&quot;&gt;线程与进程的区别&lt;/h3&gt;
&lt;p&gt;每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销，线程可以看成是轻量级的进程，&lt;strong&gt;同一类线程共享代码和数据空间&lt;/strong&gt;，一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。每个线程都有独立的运行栈和程序计时器，线程切换的开销小。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多进程: 在操作系统中能同时运行多个任务(程序) 多线程: 在同一应用程序中有多个顺序流同时执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程和线程的关系初步可以理解成：进程是加载到内存里的程序，而一个进程至少拥有一个线程(Java中的Main()方法)，当然可以使用代码进行开启多线程。&lt;/p&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Java" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Java/"/>
    
    
      <category term="Java" scheme="http://blog.geekaholic.cn/tags/Java/"/>
    
      <category term="线程" scheme="http://blog.geekaholic.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="InterruptedException" scheme="http://blog.geekaholic.cn/tags/InterruptedException/"/>
    
      <category term="异常" scheme="http://blog.geekaholic.cn/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Android控件学习之ListView</title>
    <link href="http://blog.geekaholic.cn/2016/02/06/Android%E6%8E%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0%E4%B9%8BListView/"/>
    <id>http://blog.geekaholic.cn/2016/02/06/Android控件学习之ListView/</id>
    <published>2016-02-06T14:40:28.000Z</published>
    <updated>2019-09-26T05:21:46.903Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考资料</strong>： &gt; <a href="http://www.runoob.com/w3cnote/android-tutorial-adapter.html" target="_blank" rel="noopener">Adapter基础讲解</a> &gt; <a href="http://blog.csdn.net/to_be_designer/article/details/47980475" target="_blank" rel="noopener">Android UI</a> &gt; <a href="http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html" target="_blank" rel="noopener">译文</a> &gt; <a href="http://niorgai.github.io/2014/12/13/ListView%E4%B8%8EBaseAdapter%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">ListView与BaseAdapter优化</a> &gt; <a href="http://mzh3344258.blog.51cto.com/1823534/889879" target="_blank" rel="noopener">华华世界 的BLOG</a></p><p>ListView的学习主要是适配器(Adapter)的使用以及对MVC的理解。代码尽量做到简单，为的是演示它的核心功能，不顾及界面。所以界面过丑，勿喷~~ ### 1.ArrayAdapter</p><p>只需要我们提供数据，即可以显示。显示的方式使用Android提供的布局–e.g:<code>android.R.layout.simple_expandable_list_item_1</code>。还有其他的官方提供的布局,可以修改一下试一试。</p><blockquote><p>simple_list_item_1 : 单独一行的文本框 simple_list_item_2 : 两个文本框组成，要调整数据。 simple_list_item_checked : 每项都是有一个勾选框的列表项 <img src="./images/1454742558811.jpg" title="1454742558811.jpg"> simple_list_item_multiple_choice : 都带有一个复选框 <img src="./images/1454742586021.jpg" title="1454742586021.jpg"> simple_list_item_single_choice : 都带有一个单选钮</p></blockquote><a id="more"></a><h4 id="listview主布局activity_main.xml">ListView主布局–activity_main.xml</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingLeft=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingRight=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    tools:context=<span class="string">"com.scauit.androidtest_fragmentandtextview.MainActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;ListView</span><br><span class="line">       android:id=<span class="string">"@+id/list"</span></span><br><span class="line">       android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">       android:layout_height="match_parent"&gt;&lt;/ListView&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><h4 id="listviewitem布局listviewiitem">ListViewItem布局–ListViewIitem</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span> android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:id=<span class="string">"@+id/tv_item_text"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><h4 id="mainactivy代码">MainActivy代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        String[] dataStrings = &#123;</span><br><span class="line">                <span class="string">"Java"</span>,<span class="string">"Python"</span>,<span class="string">"C"</span>,<span class="string">"C++"</span>,<span class="string">"C#"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ArrayAdapter&lt;String&gt; listAdapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,</span><br><span class="line">                android.R.layout.simple_expandable_list_item_1,dataStrings);</span><br><span class="line">        ListView ls = (ListView) findViewById(R.id.list);</span><br><span class="line">        ls.setAdapter(listAdapter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="arrayadapter的其他用法来自教程3">ArrayAdapter的其他用法:来自<a href="http://www.runoob.com/w3cnote/android-tutorial-adapter.html" target="_blank" rel="noopener">‘教程’</a></h3><blockquote><p>1.除了通过数组外，我们还可以写到一个数组资源文件中：</p></blockquote><blockquote><p>比如：在res：arrays.xml： <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string-array name=<span class="string">"myarray"</span>&gt;</span><br><span class="line">    &lt;item&gt;语文&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;数学&lt;/item&gt;</span><br><span class="line">    &lt;item&gt;英语&lt;/item&gt;</span><br><span class="line">    &lt;/string-array&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>接着布局的listview属性设置下这个列表项： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">        android:id=<span class="string">"@id/list_test"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:entries=<span class="string">"@array/myarray"</span>/&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>就可以了~</p><p>当然我们也可以在Java代码中这样写： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this,</span><br><span class="line">        R.array.myarray,android.R.layout.simple_list_item_multiple_choice );</span><br></pre></td></tr></table></figure></p><h3 id="simpleadapter">2.SimpleAdapter</h3><p>SimpleAdapter也是Android自己提供的一个Adapter适配器，它与ArrayAdapter不同的是ArrayAdapter需要使用Android自己定义的view布局文件，而SimpleAdapter则可以使用我们自己定义的布局文件。</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-06_00001.jpg" alt="SimpleAdapter"><p class="caption">SimpleAdapter</p></div><p>首先，我们先来看SimpleAdapter的构造方法：来自【<a href="http://blog.csdn.net/to_be_designer/article/details/47980475" target="_blank" rel="noopener">博客</a>】 <code>public SimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data,             @LayoutRes int resource, String[] from, @IdRes int[]to)</code></p><blockquote><p>第一个参数Context context是指当前的Activity，我们传入this即可。 第二个参数List&lt;? extends Map<string,?>&gt;是指传入的数据类型必须是List集合，集合存放的数据类型必须是Map。 第三个参数int resource是指View的布局文件。传入我们的布局文件 第四个参数 String[]from数据是以Map类型存放在List集合中的，from参数是指存放在List中每条Map数据的键值集合。 第五个参数int[] to是指将每条Map类型的数据中的不同键值对应到不同的得布局控件中。</string,?></p></blockquote><h4 id="主布局activity_main.xml">主布局activity_main.xml</h4><p>与ArrayAdapter的一样，只有一个ListView控件：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingLeft=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingRight=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    tools:context=<span class="string">"com.scauit.androidtest_fragmentandtextview.MainActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;ListView</span><br><span class="line">       android:id=<span class="string">"@+id/list"</span></span><br><span class="line">       android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">       android:layout_height="match_parent"&gt;&lt;/ListView&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><h4 id="item布局listview_item.xml">Item布局–listview_item.xml</h4><p>由于使用了第三方开源控件，需要在build.gradle中引入依赖<code>compile 'de.hdodenhof:circleimageview:2.0.0'</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    testCompile 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">    compile 'com.android.support:appcompat-v7:23.1.1'</span></span><br><span class="line"><span class="function">    compile 'de.hdodenhof:circleimageview:2.0.0'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:orientation=<span class="string">"horizontal"</span> android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line">    &lt;de.hdodenhof.circleimageview.CircleImageView</span><br><span class="line">        xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">        android:id=<span class="string">"@+id/tv_item_img"</span></span><br><span class="line">        android:layout_width=<span class="string">"100dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"100dp"</span></span><br><span class="line">        android:src=<span class="string">"@drawable/profile"</span>/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:id=<span class="string">"@+id/tv_item_text"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:text=<span class="string">"@string/app_name"</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><h4 id="mainactivy代码-1">MainActivy代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//构建Item布局中的TextView的属性值</span></span><br><span class="line">        String[] dataStrings = &#123;</span><br><span class="line">                <span class="string">"学习Java"</span>,<span class="string">"学习Python"</span>,<span class="string">"学习C"</span>,<span class="string">"学习C++"</span>,<span class="string">"学习C#"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//使用int来存储img的id，构建Item布局中的CircleImageView的属性值(为了演示方便，使用同一张图片)</span></span><br><span class="line">        <span class="keyword">int</span>[] img = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                R.drawable.profile,</span><br><span class="line">                R.drawable.profile,</span><br><span class="line">                R.drawable.profile,</span><br><span class="line">                R.drawable.profile,</span><br><span class="line">                R.drawable.profile,</span><br><span class="line">                R.drawable.profile,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建Map类型的线性表List数据，将数据存储在List&lt;Map&lt;String,Object&gt;&gt;类型中</span></span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;dataStrings.length ; i++) &#123;</span><br><span class="line">            Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"study"</span>,dataStrings[i]);</span><br><span class="line">            map.put(<span class="string">"img"</span>,img[i]);</span><br><span class="line">            dataList.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建构造方法的参数4，传入Map的键值数组</span></span><br><span class="line">        String[] from = &#123;</span><br><span class="line">                <span class="string">"study"</span>,<span class="string">"img"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//构建构造方法的参数5，传入Item布局的id，需要注意的是：</span></span><br><span class="line">        <span class="comment">//键值对与id要一一对应</span></span><br><span class="line">        <span class="keyword">int</span>[] to = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                R.id.tv_item_text,</span><br><span class="line">                R.id.tv_item_img</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//构建SimpleAdapter对象</span></span><br><span class="line">        SimpleAdapter simpleAdapter = <span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>,dataList,R.layout.listview_item,from,to);</span><br><span class="line">        ListView ls = (ListView) findViewById(R.id.list);</span><br><span class="line">        ls.setAdapter(simpleAdapter);<span class="comment">//设置</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义adapter使用最多的">自定义Adapter–使用最多的</h3><h4 id="数据-model">数据-Model</h4><p>根据MVC的思想，先构造Model–数据：(新建数据类–People)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> img;</span><br><span class="line">    <span class="keyword">private</span> String peoName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.img = R.drawable.profile;</span><br><span class="line">        <span class="keyword">this</span>.peoName = <span class="string">"无名氏"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(<span class="keyword">int</span> img, String peoName, <span class="keyword">char</span> sex, <span class="keyword">int</span> idNum, <span class="keyword">float</span> tall)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.img = img;</span><br><span class="line">        <span class="keyword">this</span>.peoName = peoName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*getter and setter*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImg</span><span class="params">(<span class="keyword">int</span> img)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.img = img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPeoName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peoName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeoName</span><span class="params">(String peoName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.peoName = peoName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视图view">视图–View</h4><p>布局文件与上述一样。</p><h4 id="自定义适配器adaptercontroller">自定义适配器Adapter–Controller</h4><p>自定义一个Adapter，让它继承自BaseAdapter，并且实现其抽象方法。 来自【<a href="http://blog.csdn.net/to_be_designer/article/details/47983017" target="_blank" rel="noopener">博客</a>】 &gt;BaseAdapter中有四个抽象的方法：public int getCount()， public Object getItem(int position)， public long getItemId(int position)， public View getView(int position, View convertview，ViewGroup viewGroup)，因此在继承BaseAdapter类后必须实现这四个方法。 &gt;public int getCount()： 　　是用来返回数据的数量的。 　　 &gt;public Object getItem(int position): 　　该方法使用来获得每一条ListView中的Item的，这里我们返回position即可，position是指每条Item在ListView中的位置（0， 1， 2……）。 　　 &gt;public long getItemId(int position)： 　　　该方法是来获得ListView中每条Item的Id的，这里我们依然返回position即可。 　　　 &gt;public View getView(int position, View convertview, ViewGroup viewGroup): 　　该方法是自定义Adapter最重要的方法，在这个方法中我们需要将数据一一对应的映射或者添加到我们自己定义的View中。然后返回view。</p><p>不需要强行记住这四个方法，使用AS的时候，当继承了BaseAdapter抽象类时，自动提醒你实现，所以，应该记住他们的功能是什么。</p><p>下面为ListViewAdapter的代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListViewAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; peoples;</span><br><span class="line">    <span class="comment">//定义Inflater,用来加载我们自定义的布局。</span></span><br><span class="line">    <span class="comment">//inflater是泵的意思，生动形象</span></span><br><span class="line">    <span class="keyword">private</span> LayoutInflater inflater;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListViewAdapter</span><span class="params">(List&lt;People&gt; peoples, LayoutInflater inflater, Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.peoples = peoples;</span><br><span class="line">        <span class="keyword">this</span>.inflater = inflater;</span><br><span class="line">        <span class="keyword">this</span>.mContext = mContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peoples.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建viewHolder对象</span></span><br><span class="line">        ViewHolder viewHolder;</span><br><span class="line">        <span class="comment">//2.获取viewHolder</span></span><br><span class="line">        <span class="comment">//2.1 convertview为空时，先使用inflater加载布局，</span></span><br><span class="line">        <span class="comment">// ViewHolder将显示在ListView中的数据通过findViewById获取到</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            viewHolder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">            <span class="comment">//从inflater中获取视图</span></span><br><span class="line">            convertView = inflater.inflate(R.layout.listview_item, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将视图的控件'赋值'给viewHolder来操作</span></span><br><span class="line">            viewHolder.circleImageView =</span><br><span class="line">                    (CircleImageView) convertView.findViewById(R.id.tv_item_img);</span><br><span class="line">            viewHolder.tv = (TextView) convertView.findViewById(R.id.tv_item_text);</span><br><span class="line">            convertView.setTag(viewHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            viewHolder = (ViewHolder) convertView.getTag();<span class="comment">//2.2 不为空时通过Tag获取viewHolder</span></span><br><span class="line">        <span class="comment">//3.获取到viewHolder，对值进行设置</span></span><br><span class="line">        viewHolder.circleImageView.setImageResource(peoples.get(position).getImg());</span><br><span class="line">        viewHolder.tv.setText(peoples.get(position).getPeoName());</span><br><span class="line">        <span class="keyword">return</span> convertView;<span class="comment">//返回视图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ViewHolder内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        CircleImageView circleImageView;</span><br><span class="line">        TextView tv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完成了数据类和适配器Adapter之后，就可以编写代码了，相对于适配器的代码来说，Activity的代码就很简单了。无非就是初始化数据，获取ListView的实例，并且设置它的适配器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; peoples;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initData();</span><br><span class="line">        ListView ls = (ListView) findViewById(R.id.list);</span><br><span class="line">        LayoutInflater layoutInflater = getLayoutInflater();<span class="comment">//获取实例</span></span><br><span class="line">        ListViewAdapter lsAdapter = <span class="keyword">new</span> ListViewAdapter(peoples,layoutInflater,<span class="keyword">this</span>);</span><br><span class="line">        ls.setAdapter(lsAdapter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       peoples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        People p2 = <span class="keyword">new</span> People(R.drawable.profile,<span class="string">"lin"</span>);</span><br><span class="line">        People p3 = <span class="keyword">new</span> People(R.drawable.profile,<span class="string">"lin2"</span>);</span><br><span class="line">        People p4 = <span class="keyword">new</span> People(R.drawable.profile,<span class="string">"lin3"</span>);</span><br><span class="line">        People p5 = <span class="keyword">new</span> People(R.drawable.profile,<span class="string">"lin4"</span>);</span><br><span class="line">        peoples.add(p1);</span><br><span class="line">        peoples.add(p2);</span><br><span class="line">        peoples.add(p3);</span><br><span class="line">        peoples.add(p4);</span><br><span class="line">        peoples.add(p5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK~大功告成。偷懒了不少，很粗略地完成了ListView的学习。难点在于自定义Adapter。而自定义Adapter的难点在于getView的重写和优化【废话！】[优化之处在于使用内部类ViewHolder以及convertView]</p><h3 id="原理浅谈与优化">3.原理浅谈与优化</h3><p>看完是不是觉得很难以理解代码？为什么这样？为什么不是那样？刚开始看郭神的《第一行代码》时，也有这种感觉，不理解getView()方法是有什么用，不理解ListView的工作原理，云里雾里。</p><p>关于convertView可以参考以下的文章，这些是个人在理解原理时收集的文章，还请仔细阅读。这里结合自己的理解，理解总结getView()方法整个过程的使用，纰漏之处，还望指出~</p><p><strong>特别重要的一点：Recycler中’回收’的是出现过又不可见的Item类型(ItemType)</strong></p><blockquote><ol style="list-style-type: decimal"><li>第一次加载ListView时会先根据ListView的高度和宽度，将<code>layoutInflater</code>读取的布局创建视图，加载在ListView可见区域，对于不可见的Item暂时不加载进内存中(记得是内存)。</li><li>比如下图中，有7个Item，会根据高度，加载每个Item的布局并创建视图。 3.使用convertView的原因在于从’布局读取’的内存方面进行优化。当Item1滑出可见区域，则被Recycler回收，该布局类型为Type1，并存在convertView当中，因为Item8的ItemType相同，均为Type1，这时候就不需要从layoutInflater中加载布局文件，而是利用convertView的View视图类型，<strong>重用布局</strong>，只更新Item8的数据，而不更新布局。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也就是说如果布局文件中有一个多选框checkbox，该checkbox与数</span></span><br><span class="line"><span class="comment">//据无关，只和布局相关，在Item1中为勾选状态，Item1滑出保存在</span></span><br><span class="line"><span class="comment">//convertView中时，在加载Item8的时候，调用getView()返回的视</span></span><br><span class="line"><span class="comment">//图Viwe是Item8的数据以及Item1的勾选状态。因为它们的布局文件</span></span><br><span class="line"><span class="comment">//一样，会使得ItemType相同，重用布局。</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="4" style="list-style-type: decimal"><li>所以convertView是从加载布局文件方面进行优化。</li><li><strong>使用ViewHolder的原因是findViewById方法耗时较大</strong>，如果控件个数过多，会严重影响性能，而使用ViewHolder主要是为了可以省去这个时间。通过setTag，getTag直接获取View。至于里面的是否要用static修饰，关于是否定义成静态，跟里面的对象数目是没有关系的，加静态是为了在多个地方使用这个Holder的时候，类只需加载一次，如果只是使用了一次，加不加也没所谓！</li><li>根据1中所述，在使用convertView的时候需要注意：</li></ol><ul><li>不可以设置listView的layout_height为wrap_content。原因是： ListView根据高度来初始化加载Item的时候，不知道本身到底要定义成多高 所以需要调用多次getView方法来计算item的高度 来填充自己，所以要match_parent或者写成固定高度。</li></ul></blockquote><div class="figure"><img src="http://old-image.geekaholic.cn/%5BAndroid%5D%20ListView%E4%B8%ADgetView%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8B%E5%A6%82%E4%BD%95%E5%9C%A8ListView%E4%B8%AD%E6%94%BE%E7%BD%AE%E5%A4%9A%E4%B8%AAitem%20-%20%E6%9C%A8%E4%B9%83%E7%8C%AB%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD.jpg" alt="原理解析经典图"><p class="caption">原理解析经典图</p></div><h3 id="其他优化">4.其他优化</h3><h4 id="onscrolllistener-图片加载">OnScrollListener-图片加载</h4><p>ListView经常需要展示图片，如果在滑动时对滑动过的每张图片都要加载，会比较占内存。推荐的优化方法是设置OnScrollListener，在滑动完成后再下载当前页面的图片。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listView.setOnScrollListener(<span class="keyword">new</span> AbsListView.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (scrollState)&#123;</span><br><span class="line">            <span class="comment">// 用户手指滑动中</span></span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:</span><br><span class="line">            <span class="comment">// 用户手指离开，但滑动动画进行中</span></span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_FLING:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 滑动结束</span></span><br><span class="line">            <span class="keyword">case</span> SCROLL_STATE_IDLE:</span><br><span class="line">                <span class="keyword">int</span> start = listView.getFirstVisiblePosition();</span><br><span class="line">                <span class="keyword">int</span> end = listView.getLastVisiblePosition();</span><br><span class="line">                <span class="keyword">if</span>(end &gt;= listView.getCount())&#123;</span><br><span class="line">                    end = listView.getCount() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//展示start－end之间的图片</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem, <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="item监听">Item监听</h4><p>当ListView的item中有比如button这些子view时，需要对其设置<code>onclickListener</code>，通常的写法是在getView方法中一个个设置，但是这种写法每次调用getView时都设置了一个新的onClick事件，效率很低。高效的写法可以直接在ViewHolder中设置一个position，然后<code>viewHolder implements OnClickListenr</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ViewHolder</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> position;</span><br><span class="line">    TextView name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="comment">//XXXX</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        convertView = inflater.inflate(R.layout.list_item, parent, <span class="keyword">false</span>);</span><br><span class="line">        holder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">        holder.name = (TextView) convertView.findViewById(R.id.name);</span><br><span class="line">        holder.name.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        convertView.setTag(holder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        holder = (ViewHolder) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置holder</span></span><br><span class="line">    holder.name.setText(list.get(position).partname);</span><br><span class="line">    <span class="comment">//设置position</span></span><br><span class="line">    holder.setPosition(position);</span><br><span class="line">    <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listview的焦点问题">ListView的焦点问题</h4><p>如果ListView中的Item中有按钮等控件抢占了焦点的获取，我们是无法使用onItem(Long)Click两个方法的，解决的办法如下：</p><blockquote><ol style="list-style-type: decimal"><li>将Item的控件焦点获取设置为false <code>android:focusable=&quot;false&quot;</code> 当然，在代码中使用方法setFocusable(false)也可以达到同样的效果。</li><li>对item的根节点进行设置: <code>android:descendantFocusability=&quot;blocksDescendants&quot;</code> viewgroup会覆盖子类控件而直接获得焦点 该属性有3个可选值，</li></ol><ul><li>beforeDescendants：viewgroup会优先其子类控件而获取到焦点</li><li>afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点</li><li>blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点</li></ul></blockquote><hr><p>虽然内容很多，但是ListView已经逐渐被新出的RecyclerView替代。学习它的原因是想了解Adapter的自定义，为RecyclerView的使用做准备，谁叫咱基础太薄弱呢~！！哈，为了我的第一个APP，下一个内容即将会是<code>RecyclerView</code>控件的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;： &amp;gt; &lt;a href=&quot;http://www.runoob.com/w3cnote/android-tutorial-adapter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adapter基础讲解&lt;/a&gt; &amp;gt; &lt;a href=&quot;http://blog.csdn.net/to_be_designer/article/details/47980475&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android UI&lt;/a&gt; &amp;gt; &lt;a href=&quot;http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;译文&lt;/a&gt; &amp;gt; &lt;a href=&quot;http://niorgai.github.io/2014/12/13/ListView%E4%B8%8EBaseAdapter%E4%BC%98%E5%8C%96/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ListView与BaseAdapter优化&lt;/a&gt; &amp;gt; &lt;a href=&quot;http://mzh3344258.blog.51cto.com/1823534/889879&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;华华世界 的BLOG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ListView的学习主要是适配器(Adapter)的使用以及对MVC的理解。代码尽量做到简单，为的是演示它的核心功能，不顾及界面。所以界面过丑，勿喷~~ ### 1.ArrayAdapter&lt;/p&gt;
&lt;p&gt;只需要我们提供数据，即可以显示。显示的方式使用Android提供的布局–e.g:&lt;code&gt;android.R.layout.simple_expandable_list_item_1&lt;/code&gt;。还有其他的官方提供的布局,可以修改一下试一试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;simple_list_item_1 : 单独一行的文本框 simple_list_item_2 : 两个文本框组成，要调整数据。 simple_list_item_checked : 每项都是有一个勾选框的列表项 &lt;img src=&quot;./images/1454742558811.jpg&quot; title=&quot;1454742558811.jpg&quot;&gt; simple_list_item_multiple_choice : 都带有一个复选框 &lt;img src=&quot;./images/1454742586021.jpg&quot; title=&quot;1454742586021.jpg&quot;&gt; simple_list_item_single_choice : 都带有一个单选钮&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Android" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Android/"/>
    
    
      <category term="Android" scheme="http://blog.geekaholic.cn/tags/Android/"/>
    
      <category term="ListView原理" scheme="http://blog.geekaholic.cn/tags/ListView%E5%8E%9F%E7%90%86/"/>
    
      <category term="ListView优化" scheme="http://blog.geekaholic.cn/tags/ListView%E4%BC%98%E5%8C%96/"/>
    
      <category term="Android控件" scheme="http://blog.geekaholic.cn/tags/Android%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>算法分析符号和算法分析浅谈</title>
    <link href="http://blog.geekaholic.cn/2016/01/19/%E7%AE%97%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%B5%85%E8%B0%88/"/>
    <id>http://blog.geekaholic.cn/2016/01/19/算法符号和算法分析浅谈/</id>
    <published>2016-01-19T13:44:50.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法分析符号及实例">算法分析符号及实例</h2><h3 id="算法分析符号">算法分析符号</h3><p>今天要为下学期的课程准备，打打酱油吧，感觉好多事要做啊啊啊啊啊。APP没有完成，JS也放下没有继续学习，就急急忙忙为下学期的《数据结构和算法》做准备，还有部门的官网任务，感觉这个假期是所有事情都不可能做好，哭。战线拉得太长了T-T</p><p>在看《算法导论》的时候，几个常见的算法分析符号把我难住了。(PS:讲的够快的，而且一堆定义，看到定义就头疼)，经过百度后，略略能get到那个point，所以赶紧做笔记，以便以后温习，怕的是没几天就忘记了，白白浪费时间。</p><a id="more"></a><p><strong>大O,Ω,Θ</strong>，主要用到的是这个符号，当然还有<strong>小o</strong>，<strong>小Ω</strong>(类似w)。下面的描述是摘自<a href="http://pake007.iteye.com/blog/87022" target="_blank" rel="noopener">pake007的博客</a>。</p><blockquote><p>f (n) = O (g (n))代表g(n)是f(n)的一个上界，即f(n)的增长率小于等于(≤)g(n)的增长率，如n^2 = O(n^3)，若f(n) = n^2, g(n) = 2n^2, 从而f(n) = O(g(n))也是正确的；</p></blockquote><blockquote><p>f (n) =Ω (g (n)) 代表g(n)是f(n)的一个下界，和O符号的意义正好相反，代表f(n)的增长率大于等于(≥)g(n)的增长率；</p></blockquote><blockquote><p>f (n) = Θ(g (n)) 代表两个函数以相同的速率增长，若f(n) = 2n^2，则写成f(n) = Θ(n^2)是最好的答案；</p></blockquote><blockquote><p>f (n) = o (g (n)) 和大O符号的意义基本相同，除了相等的情况外，即表示f(n)的增长率小于(&lt;)g(n)的增长率.</p></blockquote><blockquote><p>由理可得，小Ω代表f(n)的增长率大于(&lt;)g(n)的增长率。</p></blockquote><p>OK，看完之后有点眉目。但主要还是<strong>大O</strong>,<strong>Θ</strong>这两个经常搞混。再经过看视频和百度，Google，<code>F(n) = Θ(g(n)) 等价于 F(n) = O(g(n)) AND F(n) = Ω(g(n))</code>，并且在知乎发现了一张图，<strong>一图胜千言</strong>…所谓“增长率”和图中的“order”讲的是<strong>阶</strong>这个概念。</p><div class="figure"><img src="http://old-image.geekaholic.cn/2016-02-11_00001.jpg" alt="图片来自University of Manitoba CS3170算法分析课堂ppt"><p class="caption">图片来自University of Manitoba CS3170算法分析课堂ppt</p></div><p>由图可以看出，<strong>大O</strong>是同阶或低阶，<strong>Θ</strong>是同阶。下面举几个例子。</p><blockquote><p>n^2 = O(n<sup>3)—对的 n</sup>2 = Θ(n<sup>3)—错的 n</sup>2 = O(n<sup>2)—对的 n</sup>2 = Θ(n^2)—对的</p></blockquote><p>为什么不讲Ω这个符号，其实在算法分析中很少会涉及到<strong>最优</strong>，很多时候考虑的是<strong>最坏的情况</strong>，而且，对算法的时间复杂度T(n)，我们用符号大O来进行分析。</p><blockquote><p>T(n):定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。</p></blockquote><blockquote><p>时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n<sup>2)、立方阶O(n</sup>3)、……k次方阶O(n^k)。</p></blockquote><h3 id="实例">实例</h3><p>有了以上的概念，让我们看一些实例，一探究竟：来自<a href="http://www.xuebuyuan.com/1771236.html" target="_blank" rel="noopener">学步园</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(n^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span>. 交换i和j的内容</span><br><span class="line"></span><br><span class="line">     sum=<span class="number">0</span>；                 （一次）</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)       （n次 ）</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) （n^<span class="number">2</span>次 ）</span><br><span class="line"></span><br><span class="line">         sum++；       （n^<span class="number">2</span>次 ）</span><br><span class="line"></span><br><span class="line">解：T(n)=<span class="number">2</span>n^<span class="number">2</span>+n+<span class="number">1</span> =O(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2.4</span>.</span><br><span class="line"></span><br><span class="line">     i=<span class="number">1</span>;       ①</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=n)</span><br><span class="line"></span><br><span class="line">       i=i*<span class="number">2</span>; ②</span><br><span class="line"></span><br><span class="line">解： 语句<span class="number">1</span>的频度是<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">          设语句<span class="number">2</span>的频度是f(n),   则：<span class="number">2</span>^f(n)&lt;=n;f(n)&lt;=log2n</span><br><span class="line"></span><br><span class="line">          取最大值f(n)= log2n,</span><br><span class="line"></span><br><span class="line">          T(n)=O(log2n )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法分析符号及实例&quot;&gt;算法分析符号及实例&lt;/h2&gt;
&lt;h3 id=&quot;算法分析符号&quot;&gt;算法分析符号&lt;/h3&gt;
&lt;p&gt;今天要为下学期的课程准备，打打酱油吧，感觉好多事要做啊啊啊啊啊。APP没有完成，JS也放下没有继续学习，就急急忙忙为下学期的《数据结构和算法》做准备，还有部门的官网任务，感觉这个假期是所有事情都不可能做好，哭。战线拉得太长了T-T&lt;/p&gt;
&lt;p&gt;在看《算法导论》的时候，几个常见的算法分析符号把我难住了。(PS:讲的够快的，而且一堆定义，看到定义就头疼)，经过百度后，略略能get到那个point，所以赶紧做笔记，以便以后温习，怕的是没几天就忘记了，白白浪费时间。&lt;/p&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="计算机基础" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法分析" scheme="http://blog.geekaholic.cn/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="复杂度" scheme="http://blog.geekaholic.cn/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>理清Java中的IO-Scanner</title>
    <link href="http://blog.geekaholic.cn/2015/12/28/%E7%90%86%E6%B8%85Java%E4%B8%AD%E7%9A%84IO-Scanner/"/>
    <id>http://blog.geekaholic.cn/2015/12/28/理清Java中的IO-Scanner/</id>
    <published>2015-12-28T20:24:13.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<p>java.io.scanner 类用来从文件(包括’控制台’)中读取字符串和基本类型数值.Scanner 可以将输入分为由空白字符分隔的标记。<strong>为了能从键盘读取，需要为System.in创建一个Scanner实例</strong>，即<code>Scanner input = new Scanner(System.in);</code>。不知道还记不记得上一篇文章讲到的“标准流”？</p><blockquote><p>传送门</p></blockquote><p>当然可以从文件中读取。`Scanner input = new Scanner(new File(filename))</p><p><strong>Scanner中常见的方法：</strong></p><blockquote><p>close() : void—关闭该Scanner hasNext() : boolean —判断是否还有更多数据读取 next(): String — 从该Scanner中读取下一个标记作为字符串返回 nextLine() :String —从该Scanner中读取一行，以换行结束 nextFloat() : float—从该Scanner中读取下一个标记作为float值返回(其他基本类型同理) useDelimiliter(String) :Scanner —设置Scanner的分割符，并且返回该Scanner</p></blockquote><a id="more"></a><h2 id="scanner-如何工作">Scanner 如何工作</h2><p>当Scanner创建的时候，从指定的文件中(包括<strong>字符串</strong>，<strong>控制台</strong>)中<strong>扫描标记</strong>。Scanner中很多方法都和<code>标记</code>打交道，默认的标记是<strong>空格</strong>，可以使用上述的useDelimiliter()设置新的分隔符模式。这也可以在一定程度上解释了为什么当我们用空格分隔开输入的数据时，一般后面的数据不会被读取。</p><p><strong>那怎么样才算是一个标记呢</strong>？无论前面有多少个分割符，都看成一个，且该数值以分隔符结尾。<strong>简言之，被分隔符包围的都算一个标记</strong>。而且，要注意next()和nextLine()的不要。虽然都是读取字符串，但是next()方法读取一个由分隔符分分隔的字符串，nextLine()读取一个以换行符结束的行。</p><h3 id="代码实例">代码实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test = <span class="string">"这   是  一个  测试   字符串    "</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(test);</span><br><span class="line">        System.out.println(<span class="string">"该Scanner对象的分隔符为 ----&gt;"</span> + input.delimiter());</span><br><span class="line">        System.out.println(<span class="string">"结果如下"</span>);</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext()) &#123;</span><br><span class="line">            System.out.println(input.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input = <span class="keyword">new</span> Scanner(test);</span><br><span class="line">        input.useDelimiter(<span class="string">"个"</span>);</span><br><span class="line">        System.out.println(<span class="string">"该Scanner对象的分隔符为----&gt;"</span> + input.delimiter());</span><br><span class="line">        System.out.println(<span class="string">"新的结果如下"</span>);</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext()) &#123;</span><br><span class="line">            System.out.println(input.next());</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为： &gt; 该Scanner对象的分隔符为 —-&gt;+ 结果如下 这 是 一个 测试 字符串 该Scanner对象的分隔符为—-&gt;个 新的结果如下 这 是 一 测试 字符串</p><p>细心的应该会发现上述的方法中，有说到，“读取下一个标记作为float值返回”。对，是作为，不是读取<strong>为float值的标记</strong>，那如果该标记读取后无法转化为float类型怎么办？也就是如果标记和期望的类型不匹配。那就会抛出一个运行异常<code>java.util.InputMismatchException</code>。</p><blockquote><p>Scanner在使用之后一般要使用close()方法关闭，或者使用try-with-resources方法关闭，因为Scanner有实现AutoClosable接口。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例:Scanner 类(来自 Java API 文档)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Closes <span class="keyword">this</span> scanner.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">If <span class="keyword">this</span> scanner has not yet been closed then <span class="keyword">if</span> its underlying readable also implements the Closeable interface then the readable's close method will be invoked. If <span class="keyword">this</span> scanner is already closed then invoking <span class="keyword">this</span> method will have no effect.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Attempting to perform search operations after a scanner has been closed will result in an IllegalStateException.</span></span><br></pre></td></tr></table></figure><div class="figure"><img src="http://old-image.geekaholic.cn/%E5%9B%BE%E7%89%87%20-%20Google%20%E6%90%9C%E7%B4%A2.jpg" alt="侵删"><p class="caption">侵删</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.io.scanner 类用来从文件(包括’控制台’)中读取字符串和基本类型数值.Scanner 可以将输入分为由空白字符分隔的标记。&lt;strong&gt;为了能从键盘读取，需要为System.in创建一个Scanner实例&lt;/strong&gt;，即&lt;code&gt;Scanner input = new Scanner(System.in);&lt;/code&gt;。不知道还记不记得上一篇文章讲到的“标准流”？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传送门&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然可以从文件中读取。`Scanner input = new Scanner(new File(filename))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scanner中常见的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;close() : void—关闭该Scanner hasNext() : boolean —判断是否还有更多数据读取 next(): String — 从该Scanner中读取下一个标记作为字符串返回 nextLine() :String —从该Scanner中读取一行，以换行结束 nextFloat() : float—从该Scanner中读取下一个标记作为float值返回(其他基本类型同理) useDelimiliter(String) :Scanner —设置Scanner的分割符，并且返回该Scanner&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Java" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Java/"/>
    
    
      <category term="Java" scheme="http://blog.geekaholic.cn/tags/Java/"/>
    
      <category term="IO操作" scheme="http://blog.geekaholic.cn/tags/IO%E6%93%8D%E4%BD%9C/"/>
    
      <category term="Scanner" scheme="http://blog.geekaholic.cn/tags/Scanner/"/>
    
  </entry>
  
  <entry>
    <title>理清Java的IO(2)--流</title>
    <link href="http://blog.geekaholic.cn/2015/12/27/%E7%90%86%E6%B8%85Java%E7%9A%84IO-2/"/>
    <id>http://blog.geekaholic.cn/2015/12/27/理清Java的IO-2/</id>
    <published>2015-12-27T20:09:13.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是本博客中第二篇关于<code>Java IO</code>的文章，主要补充上一篇文章没有讲完的知识点–具体的’流’。上一篇链接:</p><blockquote><p><a href="http://garcin-lam.github.io/2015/12/27/%E7%90%86%E6%B8%85Java%E7%9A%84IO-1/" target="_blank" rel="noopener">传送门</a></p></blockquote><p>先来召唤上次文章所用的图吧。</p><p><img src="http://old-image.geekaholic.cn/javaio%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%20-%20-%20ITeye%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99.jpg" alt="图片来自网络–侵删"> <a id="more"></a> ## 常见的’流’类型</p><h3 id="文件流file-stream">文件流–File Stream</h3><p><code>FileInputStream</code> 继承自InputStream 和 <code>FileOutputStream</code> 继承自OutputStream.</p><p>这两个类类用于从/向文件读取/写入字节。它们的方法都是从InputStream和OutStream类继承的，没有引入新的方法。使用文件(<code>File</code>)对象或文件路径字符串来作为参数进行实例构造。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件输入流构造方法</span></span><br><span class="line">FileInputStream(File file)</span><br><span class="line">FileInputStream(FileDescriptor fdObj)</span><br><span class="line">FileInputStream(String name)</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件输出流构造方法</span></span><br><span class="line">FileOutputStream(File file)</span><br><span class="line">FileOutputStream(File file, <span class="keyword">boolean</span> append)</span><br><span class="line">FileOutputStream(FileDescriptor fdObj)</span><br><span class="line">FileOutputStream(String name)</span><br><span class="line">FileOutputStream(String name, <span class="keyword">boolean</span> append)</span><br></pre></td></tr></table></figure><blockquote><p>如果试图为一个<code>不存在的文件</code>创建FileInputStream对象，将会发生<code>java.io.FileNotFoundException</code>异常。</p></blockquote><blockquote><p>而对于FileOutputStream而言，如果要写入数据的File对象不存在，则会创建一个新的文件，如果文件存在，<strong>可选</strong>文件是否以追加形式写入。</p></blockquote><h3 id="转换流字节流转换到字符流">转换流–字节流转换到字符流</h3><p>注意小标题，它是<strong>单向</strong>的。有没有反向的？ &gt; 计算机都是以二进制来存储文件的。</p><p>文本文件在计算机以二进制存着，当然可以直接读，也就是说，<strong>不需要也没必要字符流转换为字节流</strong>。</p><p>它们的用处是什么？ 为了记忆方便，在上一篇文章中我们说有’-er’的是处理文本文件数据，’Stream’是处理二进制文件数据。<strong>用来将字节数据以某种编码(如UTF-8)转换到字符数据</strong>。 转换流有<code>InputStreamReader</code>(继承自<strong>Reader</strong>抽象类)和<code>OutputStreamWriter</code>(继承自 <strong>Writer</strong>抽象类)。这两个也是<code>常见的处理流</code>。 &gt;- InputStreamReader 需要和 InputStream 抽象类的子类 “套接”(PS:废话<sub>！它处理的对象是“字节数据”，当然套接在它上面啦，而且input与input相对应</sub>。“套接”就意味着要以InputStream的子类实例为构造参数)。 &gt;- 同理可得，OutputStreamWriter 需要和 OutputStream抽象类的子类 “套接”. &gt;- 转换流在构造时可以指定其<code>编码集合</code>，若不指定，默认为Unicode编码。</p><p>其中带有指定编码参数的<code>InputStreamReader</code>对象的构造方法。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader(InputStream in, CharsetDecoder dec)</span><br><span class="line">Creates an InputStreamReader that uses the given charset decoder.</span><br></pre></td></tr></table></figure></p><h3 id="过滤器数据流filter-stream">过滤器数据流–Filter Stream</h3><p><code>FilterInputStream</code>,<code>OutputStream</code>是过滤数据流的基类，它以及其子类都是<code>处理流</code>。在上一篇博客中已经介绍过，处理流是在节点流或其他处理流的基础上建立的，相当于一个大水管(处理流)“套接”在了其他小水管上面。需要“套接”在InputStream和OutputStream类型的节点流上。字节流中不是已经有了吗，怎么还需要一个过滤流。<code>存在即有理</code>。Filter Stream 是为某种目的过滤字节的数据流。</p><h4 id="data-stream">Data Stream</h4><p>Data Stream 是数据过滤流(<code>Filter Stream</code>)的其中一个子类。基本字节注入流提供的读取方法<strong>read()只能用来读取字节</strong>，而没有<strong>Java基本类型以及字符串</strong>–这就需要数据流(<code>DataInputStream</code>/<code>DataOutputStream</code>)了，它们提供的方法很方便。 试想，如果在读取文件数据的时候，你是不是读取出来之后还要进行基本类型转换？</p><p>但Filter Stream的一些子类有提供便捷的方法。存取的时候直接以该类型进行操作。比如: <code>DataInputStream</code> 和<code>DataOutputStream</code>提供了存取与机器无关的Java原始类型数据(如:int,double等)的方法(readFloat()/writeFloat()等等)，无需转换就可以从内存复制到输出数据流中。</p><p>DataOutputStream 将一个输入流的数据过滤成合适的基本类型值或者字符串。而DataOutputStream 将基本类型值或者字符串转换成字节并且输出字节到输出流中。<strong>这么看来，Data Stream 就像在程序和文件间的一个“转换器”</strong>。</p><h5 id="谈谈字符编码">谈谈字符编码</h5><p>Data Stream中还有几组有意思的方法。在这里总结一下，也可以提一下醒。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取</span></span><br><span class="line">readUTF() -- 从UTF格式中读取一个字符串</span><br><span class="line">readLine()--从输入流中读取数据行。但目前官方不推荐使用DataInputStream对象的该方法。可以使用BufferedReader对象的readLine()方法读取文本行。</span><br><span class="line"> BufferedReader d  = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));<span class="comment">/*来自官方API 文档*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">writeByte()--向输出流中写出Int类型的低八位字节</span><br><span class="line">writeBytes()---向输出流写入一个字符串中字符的低位字节</span><br><span class="line">writeChar()---向输出流中写入一个字符(由两个字节组成)</span><br><span class="line">writeChars()--向输出流中依次写入一个字符串中的每个字符</span><br><span class="line">writeUTF()---以UTF-<span class="number">8</span>格式写入一个字符串</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意不要混淆Java的char,byte 以及C语言中的char</span></span><br><span class="line"><span class="comment">  Java中的char字符型是以统一码(Unicode)编码的，也就是说Java中的char虽说是一个字符，但它是两个字节组成的，而byte是Java中的char类型的低八位，也就是一个字节。至于C语言中的char类型，因为C语言的字符型是以ASCII码进行编码，所以每个字符是8位，一个字节。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  所以输出中的writeBytes()，writeChar(),writeChars()以及writeUTF()之间有什么区别和联系？应该在什么情况下使用？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  writeBytes方法适用于ASCII码组成的字符串，因为ASCII只储存统一码的低八位。</span></span><br><span class="line"><span class="comment">  而对于不是全部由ASCII码组成的字符串(比如含有汉字)，则要使用writeUTF()和writeChars()，都是将两个字节的长度信息写入输出流。但使用UTF编码格式来存储相对更省空间，它是变长的，对于ASCII字符它只会使用1个字节，但如果使用Unicode，则使用了两个字节。所以，如果一个长字符串的大多数字符都是普通的ASCII字符，采用UTF-8格式储存更加高效。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*注意，读写如果用到UTF,则必须成对出现。也就是说，如果在数据存储的时候，使用了writeUTF()格式写入数据，则读取的时候必须使用readUTF()*/</span></span><br></pre></td></tr></table></figure><h5 id="关于utf-8编码">关于UTF-8编码</h5><blockquote><p>UTF-8是一种常用的字符编码，它是变长的，由统一码Unicode改进的编码。它根据字符的大小来使用1个字节，2个字节或者3个字节来存储字符。如果一个字符的编码值小于0X7F(即0111,1111 [逗号只是为了观看直观])，也就是ASCII码，则使用一个字节来存储。如果大于0X7F且小于等于0X7FF，则使用两个字节来存储。如果大于0X7FF则使用3个字节。UTF-8编码字符的起始几位标明这个字符是存储在一个字节两个字节还是三个字节中。如果是前4位是1110，则表明它是由3个字节序列组成的字符中的第1个字节。如果是0.则表明它是由一个字节组成的字符(ASCII)，更多具体的请查阅资料~~</p></blockquote><h5 id="例子">例子</h5><blockquote><p>writeUTF(“ABCDEF”)写入文件的是8个字节(00 06 41 42 43 44 45 46 )[16进制表示]，其中<strong>前两个字节用来存储字符串中的字符个数</strong>。</p></blockquote><p><a href="http://www.iteye.com/topic/47740" target="_blank" rel="noopener"><strong>注意，在Java中，当用UTF-8来存储中文汉字的时候，每个汉字占3个字节，而GBK是两个字节</strong></a> 可以改动下面的代码看看，将“ABCDEF”改成“ABCDEF测试”，再观察结果，就明了了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File mFile = <span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        FileInputStream mFileInputStream;</span><br><span class="line">        DataInputStream in;</span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream mFileOutputStream = <span class="keyword">new</span> FileOutputStream(mFile)) &#123;</span><br><span class="line">            DataOutputStream data = <span class="keyword">new</span> DataOutputStream(mFileOutputStream);</span><br><span class="line">            data.writeUTF(<span class="string">"ABCDEF"</span>);</span><br><span class="line">            data.close();</span><br><span class="line">            mFileOutputStream.close();</span><br><span class="line">            mFileInputStream = <span class="keyword">new</span> FileInputStream(mFile);</span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(mFileInputStream);</span><br><span class="line">            System.out.println(<span class="string">"文件字节数为"</span> + mFile.length());</span><br><span class="line">            System.out.println(<span class="string">"readUTF()读取的数据:"</span> + in.readUTF());</span><br><span class="line">            mFileInputStream.close();</span><br><span class="line">            in.close();</span><br><span class="line">            mFileInputStream = <span class="keyword">new</span> FileInputStream(mFile);</span><br><span class="line">            in = <span class="keyword">new</span> DataInputStream(mFileInputStream);</span><br><span class="line">            System.out.println(<span class="string">"readByte()读出的数据："</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%x "</span>,in.readByte());<span class="comment">//16进制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException eof) &#123;</span><br><span class="line">            System.out.println(<span class="string">"\ndone!"</span>);<span class="comment">//到达结尾抛出EOF异常，要捕获。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">            ee.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓冲流buffered-stream">缓冲流–Buffered Stream</h4><p>BufferedInputStream 和 BufferedOutputStream 类可以<strong>减少磁盘读写次数</strong>来提升输入和输出的速度。使用BufferedInputStream时，磁盘上的整块数据一次性地读入到内存中的缓冲区。然后从缓冲区中将<strong>个别数据</strong>传递到程序中。使用BufferedOutputStream时，个别的数据首先写入到内存中的缓冲区中，当缓冲区已满时，缓冲区中的所有数据一次性写入到磁盘中。</p><p><strong>构造方法</strong> &gt;- 1.BufferedInputStream(InputStream in) Creates a BufferedInputStream and saves its argument, the input stream in, for later use. &gt;- 2.BufferedInputStream(InputStream in, int size) Creates a BufferedInputStream with the specified buffer size, and saves its argument, the input stream in, for later use.</p><p>如果不指定缓冲区大小，默认大小为512个字节。不管对于多大的文件，<strong>都应该使用</strong>缓冲区I/O来加速输入输出。 ### 对象流 – Object Stream</p><p>对象类可以用来读写可序列化的对象，所谓可序列化对象是指该类实现了可序列化Serializable接口，这样可以将对象直接转换为字节流。</p><h4 id="对象流和数据流的关系">对象流和数据流的关系</h4><ul><li>在前面我们已经知道，DataInputStream 类 和 DataOutputStream类可以实现<strong>基本数据类型与字符串的输入和输出</strong>，但ObjectInputStream 和 ObjectOutputStream 除了<strong>基本数据类型与字符串的输入和输出</strong>外，还可以实现对象的输入和输出。可以看出，ObjectOutputStream 和 ObjectInputStream 包括了 DataInputStream和DataOutStream的所有功能，完全可以使用前两者代替后两者。</li><li>ObjectInputStream 和 DataInputStream 都扩展了InputStream抽象类，前者实现了接口ObjectInput，后者实现了接口DataInput。ObjectInput 接口 是 DataInput接口的子接口，并且多了一个readObject()的抽象方法(ObjectOutputStream 和 DataOutputStream同理)。除了ObjectInput接口外，ObjectInputStream和ObjectOutputStream还实现了接口ObjectStreamConstants，从名字中就可以看出来，该接口包含了ObjectInputStream 和 ObjectOutputStream所使用的<strong>常量</strong>。</li><li>都要遵循以数据写入文件时的顺序和格式从文件中读取这些数据。</li></ul><h4 id="serializable关键字">serializable关键字</h4><ul><li><p>serializable “可序列化的”。它是一个接口，一种标记接口，因为没有方法。实现这个接口可以启动Java的序列化机制，自动完成存储对象和数组的过程。在ObjectOutStream中完成将可序列化的对象写入文件，这个过程称为<code>序列化</code>。在ObjectInputStream中完成将文件中的可序列化对象读取出来，这个过程称为<code>反序列化</code>。 当储存一个可序列化对象时，会对该对象的类进行编码。编码包括类名、类的签名、对象实例变量的值以及该对象引用的任何其他对象的<code>闭包</code>，但是<strong>不存储对象静态变量的值</strong>。</p></li><li><p>externailzable 接口 Serializable的子接口，它的作用是让程序员自定义序列化过程。<strong>已经超出本人目前能力之外，不予讨论。</strong></p></li></ul><h4 id="非序列化的数据域">非序列化的数据域</h4><p>已经知道，对象的静态变量的值不会存储。如果一个对象是Serializable的实例，但它包含了非序列化的实例数据域，那么就不可以序列化这个对象。一个对象保证能够被序列化，就要<strong>必须保证其数据域都可被序列化</strong>。还有一种方法是<code>transient</code>关键字，它的作用是告诉Java虚拟机将对象写入流的时候，<strong>忽略这些数据域</strong>。</p><h4 id="重复的对象处理">重复的对象处理</h4><blockquote><p><strong>来自《Java语言程序设计(基础篇)》</strong> 如果一个对象不止一次写入对象流，会存储对象的多个副本吗？答案是不会。第一次写入一个对象的时候，就<strong>会为它创建一个序列号</strong>。Java虚拟机<strong>将对象的所有内容和序列号一起写入</strong>对象流中。以后每次存储时，如果再写入相同的对象，就只存储序列号。读出这些对象时，它们的引用相同，因为在内存中实际上存储的只是一个对象。</p></blockquote><h3 id="标准输入流">“标准”输入流</h3><p>System.in 是“standard” InputStream(标准输入流)，这里的InputStream是父类指向子类引用对象(<code>多态性</code>)，其实<strong>System.in是BufferedStream的一个实例</strong>。也就是InputStream的一个子类。可以把它看成获取键盘的输入。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.in.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>运行结果： java.io.BufferedInputStream</p></blockquote><p><strong>为什么是BufferedInputStream</strong>?在我迷惑的时候，去翻过Java API文档，但找不到答案。最终还是在<code>StackOverFlow</code>上找到了答案。其实“答案”在Java源码中可以看得到。</p><p>用<code>NetBeans</code>或者其它IDE，ctrl+点击“in”进入’System.java’，当然其他方式也可以。</p><blockquote><ol start="83" style="list-style-type: decimal"><li>public final static InputStream in = null;</li></ol></blockquote><blockquote><ol start="257" style="list-style-type: decimal"><li>private static native void setIn0(InputStream in);</li></ol></blockquote><blockquote><ol start="1188" style="list-style-type: decimal"><li>FileInputStream fdIn = new FileInputStream(FileDescriptor.in);</li></ol></blockquote><blockquote><ol start="1191" style="list-style-type: decimal"><li>setIn0(new BufferedInputStream(fdIn));//就是在这里</li></ol></blockquote><h3 id="print流">print流</h3><p>PrintWriter 和 PrintStream都属于输出流，分别针对字符和字节。 两者都提供了重装的print PrintWriter和PrintStream的输出操作不会抛出异常，用户通过检测错误状态获取错误信息。(方便)？什么来的 PrintWriter和PrintStream有自动flush的功能。</p><p>PrintfWriter的构造方法有点特殊。它可以有Writer的子类或者OutputStreamd的子类作为构造参数。所以它也是一种处理流。</p><p><strong>注意</strong>:System.out是PrintfStream类型。System.in是InputStream类型。System.out.print()默认的输出是DOS窗口(标准输出)，但如果在方法中使用了System.setOut(PrintfStream)，会将默认的输出改变成设置的PrintStream目标，而不再是DOS窗口(屏幕)。<strong>屏幕也是一种’文件’</strong></p><p>例子 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用print流实现将test.txt文件中的字符串打印到new.txt中</span></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File mFile = <span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        File mNewFile = <span class="keyword">new</span> File(<span class="string">"D:\\new.txt"</span>);</span><br><span class="line">        Scanner in;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintStream mOut = <span class="keyword">new</span> PrintStream(mNewFile);</span><br><span class="line">            in = <span class="keyword">new</span> Scanner(mFile,<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                System.out.print(in.nextLine());</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            in = <span class="keyword">new</span> Scanner(mFile,<span class="string">"UTF-8"</span>);</span><br><span class="line">            System.setOut(mOut);</span><br><span class="line">             <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.nextLine());</span><br><span class="line">                 System.out.println(<span class="string">"这句话也会在new.txt文件中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到文件"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="try-with-resources">try-with-resources</h2><h3 id="两种方式">两种方式</h3><p>这个是什么东西？其实，使用它来声明和创建输入输出流，从而在使用后可以自动关闭。 我们都知道，Java I/O操作都会抛出异常，需要我们进行关闭。而我们也知道，在操作完流之后，需要使用close()方法将它关闭。不关闭<code>流</code>可能会在输出文件中造成数据受损，或者导致其他的程序出错。但除了这种方法之外，还有一种简洁的方法。就是<code>try-with-resources</code>。</p><h3 id="代码实例">代码实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader mFileReader ;</span><br><span class="line">            <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">            File mFile = <span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">            mFileReader = <span class="keyword">new</span> FileReader(mFile);</span><br><span class="line">            System.out.println(<span class="string">"我是节点流对象mFileReader读取的数据"</span>);</span><br><span class="line">            <span class="comment">//一个字符一个字符地读取，当read()返回值为-1时，读取结束</span></span><br><span class="line">            <span class="keyword">while</span> (mFileReader.read(value, <span class="number">0</span>, <span class="number">1</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(Arrays.toString(value));</span><br><span class="line">            &#125;</span><br><span class="line">            mFileReader.close();<span class="comment">//读写结束后需要关闭</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">            ee.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法2 try-with-resources</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File mFile = <span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span>(FileReader mFileReader=<span class="keyword">new</span> FileReader(mFile)) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">            System.out.println(<span class="string">"我是节点流对象mFileReader读取的数据"</span>);</span><br><span class="line">            <span class="comment">//一个字符一个字符地读取，当read()返回值为-1时，读取结束</span></span><br><span class="line">            <span class="keyword">while</span> (mFileReader.read(value, <span class="number">0</span>, <span class="number">1</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(Arrays.toString(value));</span><br><span class="line">            &#125;</span><br><span class="line">            mFileReader.close();<span class="comment">//读写结束后需要关闭</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">            ee.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理解说">原理解说</h3><blockquote><p><strong>来自《Java语言程序设计(基础篇)》</strong> 程序使用了<code>try-with-resources</code> 来声明和创建输入输出流，从而在使用后可以自动关闭。java.io.InputStream和java.io.OutputStream实现了<code>AutoClosable接口</code>。该接口定义了close()方法，用来关闭资源，任何AutoClousable类型的对象都可以用于try-with-resources语法中，实现其自动关闭。</p></blockquote><p>其实实现该接口的还有Scanner,Reader,Writer。目前接触涉及I/O的类都有close()方法，都有实现AutoClosable接口。</p><h2 id="吐吐槽">吐吐槽</h2><p>花了3天的时间来写关于I/O的，那感觉，满脑子都是’流’啊，’Scanner’等等的概念。估计要疯了。。。因为实在是太多了，整理的过程中总要想着如何排版更加合理，怎么说才能尽可能地述说完整。。。加上自己是菜鸟，总怕说错，不断地查文档和搜索，结果下来，发现还有很多琐碎的关于I/O的知识点等着T^T，还是加油吧~~！其实有很多类我们只需要了解就好，常见的I/O操作也就Scanner，Object Stream，Data Stream，File Stream，Buffered Stream.那为什么要将其他的像print流。 &gt; 因为它在那里。</p><p>(<strong>PS：这篇文章那么长，难免会出错。如果哪里有错还望指出，记得轻拍</strong>。)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这是本博客中第二篇关于&lt;code&gt;Java IO&lt;/code&gt;的文章，主要补充上一篇文章没有讲完的知识点–具体的’流’。上一篇链接:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://garcin-lam.github.io/2015/12/27/%E7%90%86%E6%B8%85Java%E7%9A%84IO-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来召唤上次文章所用的图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://old-image.geekaholic.cn/javaio%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%20-%20-%20ITeye%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99.jpg&quot; alt=&quot;图片来自网络–侵删&quot;&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Java" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Java/"/>
    
    
      <category term="Java" scheme="http://blog.geekaholic.cn/tags/Java/"/>
    
      <category term="IO操作" scheme="http://blog.geekaholic.cn/tags/IO%E6%93%8D%E4%BD%9C/"/>
    
      <category term="流类型" scheme="http://blog.geekaholic.cn/tags/%E6%B5%81%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>理清Java的IO(1)--流</title>
    <link href="http://blog.geekaholic.cn/2015/12/27/%E7%90%86%E6%B8%85Java%E7%9A%84IO-1/"/>
    <id>http://blog.geekaholic.cn/2015/12/27/理清Java的IO-1/</id>
    <published>2015-12-27T10:14:00.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>声明:由于I/O操作的<code>Scanner</code>类不在java.io包内，不属于文中的主角–‘<code>流类型</code>’，故留着最后，防止解说过于混乱</strong></p></blockquote><h2 id="概念">概念</h2><h3 id="相关包">相关包</h3><blockquote><p><code>java.io</code>、<code>java.util</code> (Scanner这个特殊的存在)</p></blockquote><h3 id="文件"><code>文件</code></h3><blockquote><p>文件就是字节序列。<strong>每一个I/O设备，包括磁盘，键盘，显示器，甚至网络都可以视为文件</strong>。–摘自《CSAPP》</p></blockquote><p>至于在文件中，文本文件和二进制文件的区别，可以看上一篇文章。</p><h3 id="流"><code>流</code></h3><p>在Java的<code>I/O操作</code>中，流是一个很重要的概念。在计算机的基础课程中，有学习过<code>数据流</code>，<code>控制流</code>等，这是一种类比的思想，将Java的I/O操作更加形象地描述出来。在视频或者书籍中，都喜欢用’流’来描述<code>文件读取</code>的过程。为了便于理解和记忆，姑且可以把’<strong>流’看成’水流’</strong>，而<strong>涉及’I/O操作的类’看成’管道’</strong>，<strong>‘文件和程序’看出’水池’</strong>。</p><div class="figure"><img src="http://old-image.geekaholic.cn/sxt-javaio.jpg" alt="来自马士兵的Java视频"><p class="caption">来自马士兵的Java视频</p></div><p><br></p><a id="more"></a><h2 id="流的分类">流的分类</h2><p><code>java.io</code> 包中定义了多个<code>流类型</code>(类或抽象类)来实现输入/输出功能。在刚开始学习<code>Java</code>的<code>I/O操作</code>时，着实给那么多的类和方法吓到了。也有时搞不清楚，为什么一些类的构造方法是其他的I/O类为参数，而一些类的构造方法是<code>File类</code>或者<code>文件路径字符串</code>为参数如果不细细地梳理，可能在使用的时候就会很混乱。(虽然可以查找<code>API 文档</code>)。</p><h3 id="个人记忆方法">个人记忆方法</h3><p>那我们开门见山吧~其实很简单。[<strong>请紧记于心</strong>] <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">就两个<span class="string">"大类"</span>--文本I/O和二进制I/O。</span><br><span class="line">最后的单词是<span class="string">'-er'</span>的(包括Scanner)是处理文本文件数据，<span class="string">'-Stream'</span>可以处理二进制文件数据**以及文本数据**。</span><br></pre></td></tr></table></figure></p><p><strong>为什么这样分</strong>？！</p><p>SDK 所提供的所有流类型位于包java.io内都分别继承自以下4种<strong>抽象</strong>流类型。</p><table><thead><tr class="header"><th>流的类型</th><th><code>字节流</code></th><th><code>字符流</code></th></tr></thead><tbody><tr class="odd"><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr class="even"><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>[四种抽象流类型]</p><blockquote><p>抽象类<code>InputStream</code>是读取二进制数据的根类，抽象类<code>OutputStream</code>是写入二进制数据的根类。</p></blockquote><p><strong>字节流一般处理的是二进制文件(包括文本)，而字符流处理的是文本文件</strong>。 再来看一副图。这幅图替我们总结了IO操作中的IO’流’类。<strong>这只是常见的，并不是所有。请注意</strong></p><div class="figure"><img src="http://old-image.geekaholic.cn/javaio%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%20-%20-%20ITeye%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99.jpg" alt="网络图片–侵删"><p class="caption">网络图片–侵删</p></div><p><br></p><p>仔细看图中的类，可以看到<strong>I/O处理的类大部分是对称的</strong>。也就是大部分4个一起出现。</p><p>当然，也可以从不同的角度对其进行分类，关键是<strong>怎么记忆怎么来</strong>。比如: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">按照数据流的方向不同可以分为输入流和输出流</span><br><span class="line">按照处理数据单位不同可以分为字节流和字符流</span><br><span class="line">按照功能不同可以分为节点流和处理流</span><br></pre></td></tr></table></figure></p><p>先来解释这3种不同分法的’流’。</p><h3 id="输入流和输出流inputoutput-stream"><code>输入流</code>和<code>输出流</code>(Input/Output Stream)</h3><p>输入流和输出流 在程序和文件当中，<strong>输入流和输出流是相对的</strong>。当读取文件的时候，从程序的角度看，<strong>文件数据</strong>是输入流，从文件的角度看则是输出流。<strong>输入输出是相对于参考体而已的，远离则为输出。</strong></p><h3 id="字节流和字符流byte-streamcharacter-stream"><code>字节流</code>和<code>字符流</code>(byte Stream/character Stream)</h3><ul><li>字节流的数据处理单位是字节(8bit)</li><li>字符流的数据处理单位是2个字节的Unicode 字符(16bit)</li></ul><p>为什么存在字节流还需要字符流？因为存在二进制文件和文本文件。 ### <code>节点流</code>和<code>处理流</code></p><ul><li>节点流为可以从一个特定的数据源(节点)直接读取数据。</li><li>处理流是“连接”在已经存在的流(<strong>节点流或处理流</strong>)之上，通过对数据的处理，为程序提供更为强大的读写功能。</li></ul><p>看到<code>节点流</code>和<code>处理流</code>，应该知道为什么一些类的构造方法是其他的I/O类为参数，而一些类的构造方法是<code>File类</code>或者<code>文件路径字符串</code>为参数了吧？</p><h4 id="构造方法不同的原因">构造方法不同的原因</h4><p>以“程序以<code>FileReader</code>类读取文件”的过程为例。按照前面所说的思维方法，把’<strong>流’看成’水流’</strong>，而<strong>涉及’I/O操作的类’看成’管道’</strong>，<strong>‘文件和程序’看出’水池’</strong>。</p><blockquote><p>1.文件读取流，首先是利用文件的地址字符串或者文件(File)对象，进行建立，成为了<strong>节点流</strong>。</p></blockquote><p>这个过程可以看作是:</p><blockquote><p>要从一个水池A(文件)中取水到另外水池B(程序运行时分配的内存空间)，首先把小的管道(‘节点流’类型的类,FileReader)插在水池的出水口。这个插的过程相当于<strong>构造</strong>一个’节点流’。所以，FileReader 对象的构造方法中要有File 对象 或者 “文件路径的字符串”。这时就是<code>节点流</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader的<span class="number">3</span>个构造方法：</span><br><span class="line"></span><br><span class="line">FileReader(File file)</span><br><span class="line">Creates a <span class="keyword">new</span> FileReader, given the File to read from.</span><br><span class="line">FileReader(FileDescriptor fd)</span><br><span class="line">Creates a <span class="keyword">new</span> FileReader, given the FileDescriptor to read from.</span><br><span class="line">FileReader(String fileName)</span><br><span class="line">Creates a <span class="keyword">new</span> FileReader, given the name of the file to read from.</span><br></pre></td></tr></table></figure><blockquote><p>2.而为了更加方便地读写数据和操作文件(因为处理流提供了很多好用的方法，如BufferedReader的readLine()可以读取一行数据)，引入了处理流。处理流的构造方法参数为节点流或者处理流的子类。</p></blockquote><p>这个过程可以看作是: &gt; 在取水的时候，发现水中有杂质。想要它先缓冲在一个地方进行过滤、沉淀，等到一定的水量之后再一次输入到水池B中。这时我需要一个带有过滤头并且具有缓冲功能的大水管(‘处理流’类型的类,BufferReader)。所以，BufferedReader中的构造参数要有’节点流’对象。这时候就是’处理流’。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader的<span class="number">2</span>个构造方法：</span><br><span class="line"></span><br><span class="line">BufferedReader(Reader in)</span><br><span class="line">Creates a buffering character-input stream that uses a <span class="keyword">default</span>-sized input buffer.</span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> sz)</span><br><span class="line">Creates a buffering character-input stream that uses an input buffer of the specified size.</span><br></pre></td></tr></table></figure><h4 id="代码实例">代码实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader mFileReader ;</span><br><span class="line">            <span class="keyword">char</span>[] value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">            File mFile = <span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>);</span><br><span class="line">            mFileReader = <span class="keyword">new</span> FileReader(mFile);</span><br><span class="line">            System.out.println(<span class="string">"我是节点流对象mFileReader读取的数据"</span>);</span><br><span class="line">            <span class="comment">//一个字符一个字符地读取，当read()返回值为-1时，读取结束</span></span><br><span class="line">            <span class="keyword">while</span> (mFileReader.read(value, <span class="number">0</span>, <span class="number">1</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(value);</span><br><span class="line">            &#125;</span><br><span class="line">            mFileReader.close();<span class="comment">//读写结束后需要关闭</span></span><br><span class="line">            System.out.println(<span class="string">"\n~~~~~华丽丽的分割线~~~~~"</span>);</span><br><span class="line">            mFileReader=<span class="keyword">new</span> FileReader(mFile);<span class="comment">//重新打开</span></span><br><span class="line">            BufferedReader mBufferedReader = <span class="keyword">new</span> BufferedReader(mFileReader);</span><br><span class="line">            System.out.println(<span class="string">"\n我是处理流对象mBufferedReader读取的数据"</span>);</span><br><span class="line">            System.out.println(mBufferedReader.readLine());<span class="comment">//只需要一句话</span></span><br><span class="line">            mFileReader.close();<span class="comment">//读写结束后需要关闭</span></span><br><span class="line">            mBufferedReader.close();<span class="comment">//关闭</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">            ee.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行结果</span><br><span class="line"></span><br><span class="line">我是节点流对象mFileReader读取的数据</span><br><span class="line">Hello,我是编执狂。欢迎来到Geekaholic的博客~</span><br><span class="line">~~~~~华丽丽的分割线~~~~~</span><br><span class="line">我是处理流对象mBufferedReader读取的数据</span><br><span class="line">Hello,我是编执狂。欢迎来到Geekaholic的博客~</span><br></pre></td></tr></table></figure><p>总结一下，<strong>因为某一些流是处理流，是建立在其他节点流或处理流的基础之上，(相当于在节点流的“管道”基础上再套接一个管道)，所以构造方法需要某个’节点流’或’处理流’类型的对象为构造参数。</strong>从程序中可以看到，更加方便地读写数据和操作文件。</p><h4 id="常见的处理流">常见的<code>处理流</code></h4><p><strong>字节流-输入流</strong> ObjectInputStream(对象流)，SequenceInputStream(合并流)，FilterStream和它的子类(BufferedInputStream,DataInputStream等)。</p><p><strong>字节流-输出流</strong> ObjectOutputStream(对象流)，FilterStream和它的子类(BufferedOutputStream,DataOutputStream等)。</p><p><strong>字符流-输入流</strong> BufferedReader,InputStreamReader(转换流),FilterReader和它的子类。</p><p><strong>字符流-输出流</strong> BufferedWriterer,InputStreamWriter(转换流),FilterWriter和它的子类。</p><p>它们还是有一定的规律性的，比较对称。要查更多，请参照Java官方的<code>API文档</code>。要记住全部也不现实，但要记得一点。<strong>处理流是在节点流或处理流的基础上构造的</strong>，它可以(不是必须)用“节点流”对象做构造参数。</p><h3 id="总结">总结</h3><p>从两大类–<code>文本I/O</code>和<code>二进制I/O</code>来梳理’流’。并从大的方向区分了各式各样的’流类型’，分享了记忆方法。 &gt; 二进制I/O类中的所有方法都声明为抛出java.io.IOException或其子类。</p><p>【还有…】 因为IO操作的内容太庞大了，所以只能将它们分隔开来。这一篇主要从大的分类方向梳理I/O处理的“流”，第二篇会继续更新常见的具体’流’类，第三篇将更新Scanner的知识，比如工作原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;声明:由于I/O操作的&lt;code&gt;Scanner&lt;/code&gt;类不在java.io包内，不属于文中的主角–‘&lt;code&gt;流类型&lt;/code&gt;’，故留着最后，防止解说过于混乱&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;h3 id=&quot;相关包&quot;&gt;相关包&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java.io&lt;/code&gt;、&lt;code&gt;java.util&lt;/code&gt; (Scanner这个特殊的存在)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;文件&quot;&gt;&lt;code&gt;文件&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;文件就是字节序列。&lt;strong&gt;每一个I/O设备，包括磁盘，键盘，显示器，甚至网络都可以视为文件&lt;/strong&gt;。–摘自《CSAPP》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于在文件中，文本文件和二进制文件的区别，可以看上一篇文章。&lt;/p&gt;
&lt;h3 id=&quot;流&quot;&gt;&lt;code&gt;流&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在Java的&lt;code&gt;I/O操作&lt;/code&gt;中，流是一个很重要的概念。在计算机的基础课程中，有学习过&lt;code&gt;数据流&lt;/code&gt;，&lt;code&gt;控制流&lt;/code&gt;等，这是一种类比的思想，将Java的I/O操作更加形象地描述出来。在视频或者书籍中，都喜欢用’流’来描述&lt;code&gt;文件读取&lt;/code&gt;的过程。为了便于理解和记忆，姑且可以把’&lt;strong&gt;流’看成’水流’&lt;/strong&gt;，而&lt;strong&gt;涉及’I/O操作的类’看成’管道’&lt;/strong&gt;，&lt;strong&gt;‘文件和程序’看出’水池’&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;http://old-image.geekaholic.cn/sxt-javaio.jpg&quot; alt=&quot;来自马士兵的Java视频&quot;&gt;
&lt;p class=&quot;caption&quot;&gt;来自马士兵的Java视频&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Java" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Java/"/>
    
    
      <category term="Java" scheme="http://blog.geekaholic.cn/tags/Java/"/>
    
      <category term="IO操作" scheme="http://blog.geekaholic.cn/tags/IO%E6%93%8D%E4%BD%9C/"/>
    
      <category term="流类型" scheme="http://blog.geekaholic.cn/tags/%E6%B5%81%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>理清Java异常(2)</title>
    <link href="http://blog.geekaholic.cn/2015/12/26/%E7%90%86%E6%B8%85Java%E5%BC%82%E5%B8%B8-2/"/>
    <id>http://blog.geekaholic.cn/2015/12/26/理清Java异常-2/</id>
    <published>2015-12-26T13:20:29.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<p>当一个语句在代码运行的时候可能会出错时(不可避免的错误，不为程序员在编写代码时可控制，比如文件不存在等)，我们应该如何处理？上一回讲到了<a href="http://garcin-lam.github.io/2015/12/26/%E7%90%86%E6%B8%85Java%E5%BC%82%E5%B8%B8-1/" target="_blank" rel="noopener">异常的概念和分类</a>，那我们来深入了解一下<strong>异常的处理</strong>。</p><h2 id="异常的处理">异常的处理</h2><p>在《理清Java异常(1)》中，我们简单地说了Java必检异常的处理方式。<strong>主要有两种处理(但解决异常的方法主要有一种，就是try-catch)</strong>。怎么知道是必检异常？查看Java API文档中类的继承，除了Error和RunTimeException及它们子类，其他Exception类就是必检异常。</p><blockquote><ul><li>声明和抛出异常</li><li>try-catch块捕获异常</li></ul></blockquote><p>注意，还要区别“处理”这个词的上下文或者说意境。其实说<strong>两种处理方式并不怎么准确，它可能会混淆视听</strong>。(PS：好吧，当我咬文嚼字吧-.-!!)</p><blockquote><p>当方法B调用会抛出异常的方法C，C出错抛出异常时，方法B使用try-catch捕获到异常，它有<strong>两种处理手段</strong>，可以选择在catch语句块中<strong>继续抛出(throw)异常</strong>(补充:’继续抛出’也可以不使用try-catch，直接声明异常即可)，让B的调用方法A用try-catch<strong>解决异常</strong>，也可以在方法B的catch语句块中<strong>解决异常</strong>。</p></blockquote><p>简而言之，异常只需要“解决”一次，当一个异常对象被捕获并被解决时，它会“消失”。但一个异常对象可以有两种“处理手段”，<strong>1.继续抛出</strong>，<strong>2.解决异常</strong>。 <a id="more"></a> 以上“咬文嚼字”的过程涉及三个操作–1.声明异常，2.抛出异常，3.捕获异常。 #### 代码实例 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;<span class="comment">//引入需要的包</span></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        B();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="comment">// B选择的处理方法是抛出给A方法处理，A</span></span><br><span class="line">         System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">throws</span> IOException<span class="comment">/*声明IO异常,关键字throws*/</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">        File mFile = <span class="keyword">new</span> File(<span class="string">"myFile.dat"</span>);</span><br><span class="line">        FileInputStream input = <span class="keyword">new</span> FileInputStream(mFile);</span><br><span class="line">        <span class="comment">//方法C</span></span><br><span class="line">        <span class="comment">//IO其他操作</span></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="comment">//1.继续抛出,关键字throw</span></span><br><span class="line">        <span class="comment">//如果该方法无法解决该异常，或者只是简单地希望它的</span></span><br><span class="line">        <span class="comment">//用者(方法A)注意到该异常，可以抛出异常让A解决</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">        <span class="comment">//2.解决异常,这里选择直接打印</span></span><br><span class="line">        <span class="comment">//System.out.println("出错+"e);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="声明和抛出异常">声明和抛出异常</h3><h4 id="声明异常关键字throws">声明异常(关键字:throws)</h4><p>每个方法都必须声明它可能抛出的<strong>必检异常的类型</strong>。这样，方法的调用者会被告知有异常抛出，必须处理(注意是’处理’哦，不是’解决’)。<strong>这也是为什么在使用某些对象的方法时，IDE会报错，一定要你处理抛出的异常</strong>。</p><h4 id="抛出异常关键字throw">抛出异常(关键字:throw)</h4><p>检测到错误的程序可以创建一个合适的异常类型对象，并把它抛出，这就称为抛出异常。(一般使用if语句判断，对于无法处理的就抛出异常。<strong>问题1？在文末讲</strong>)</p><p>注意是抛出对象，所以使用 <code>throw new IllegalArgumentException(&quot;*&quot;)</code> 抛出异常对象。Java API 中有一些方法已经throw 异常，则不需要我们在自己的调用方法中<strong>手动抛出</strong>，但是，如果在一个声明了throws 异常的方法中，没有调用到有throw异常的方法，必须要手动抛出异常，即<strong>实例化一个异常对象并抛出</strong>。否则，在方法头声明异常的方法会报错。</p><p>一般来说，Java API中的每个异常类至少有两个构造方法 : 一个无参构造方法和一个带可描述这个异常的String参数的构造方法，该参数也称为 <em>异常信息</em> 。</p><blockquote><p>异常信息可以使用异常对象的 <code>getMessage()</code> 获取。【见代码部分】</p></blockquote><h4 id="捕获异常关键字trycatchfinally">捕获异常(关键字:try,catch,finally)</h4><p>使用try语句块包含可能出错的方法，使用catch语句块捕获可能出现的异常。只有catch语句块中的异常对象相匹配，才会执行catch语句块中的语句。</p><p>注意:catch异常对象只需声明引用，如Exception e;这样我们就可以直接使用了。那对象的初始化呢？异常在Java运行时系统抛出异常对象时已帮我们自动初始化对象，即’new Exception()’。</p><p><strong><em>finally</em> 关键字</strong></p><p>无论异常是否产生或者是否被捕获，finally子句总是会执行。finally 语句为异常处理提供了一个统一的出口，使得在控制流程转到程序的其他部分之前，<strong>能对程序的状态作统一的管理</strong></p><p>通常在finally语句中可以进行资源的清除工作，如： - 关闭打开的文件 - 删除临时文件 - ……</p><blockquote><p>关于try-catch-finally 捕获异常的执行过程详见 <a href="http://garcin-lam.github.io/2015/12/26/%E7%90%86%E6%B8%85Java%E5%BC%82%E5%B8%B8-3/" target="_blank" rel="noopener">捕获异常的执行过程</a></p></blockquote><h4 id="代码">代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">     Exc() &#123;</span><br><span class="line">        setRadius(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Exc(<span class="keyword">double</span> r) &#123;</span><br><span class="line">        setRadius(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Exc circle = <span class="keyword">new</span> Exc(<span class="number">5.0</span>);</span><br><span class="line">            Exc circle2 = <span class="keyword">new</span> Exc(-<span class="number">5.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IllegalArgumentException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"构造函数的参数为:"</span>+e.getMessage());</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> r)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)    System.out.println(<span class="string">"正常"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"出错！半径小于0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下： &gt; 正常 构造函数的参数为:出错！半径小于0 java.lang.IllegalArgumentException: 出错！半径小于0</p><h3 id="何时使用异常">何时使用异常</h3><p>上面在讲抛出异常的时候遗留了一个问题。相信有一部分人在看到<strong>使用if语句判断然后抛出异常</strong>，都会认为，既然可以判断了，为什么不直接将异常解决，还要抛出给调用方法呢？(答案在第三点)这其实也是我在第一次在Java课堂上接触了<strong>异常处理</strong>时候的一个疑惑。但在书中找到了答案(所以说，书还是要看，不能卷起袖管就开撸代码~)，<a href="http://book.douban.com/subject/6529833/" target="_blank" rel="noopener">书中</a>讲得很清楚，而且还包括了很多要点。在理解的基础上整理的要点如下。</p><blockquote><ol style="list-style-type: decimal"><li>异常出现在方法中，如果想让该方法的调用者<strong>解决</strong>异常，应该创建一个异常对象并将其抛出。如果能在发生异常的方法<strong>解决</strong>异常，那么就不需要抛出或使用异常了。(这已经在上面的“咬文嚼字”详细地说明)</li><li>一般来说，一个项目中多个类都会发生的<strong>共同异常</strong>应该考虑作为一种异常。</li><li><strong>什么时候应该抛出异常？</strong> 当错误需要被方法的调用者<strong>处理</strong>(不一定是’解决’)的时候，方法应该抛出异常。为什么？以上面设置圆的半径为例，在用户输入圆的半径的时候，构造方法调用setRaidus()方法。假设某个调皮捣蛋的用户，或者说是闲着蛋疼没事干的用户，输入了小于0的数字，setRadius()方法会出现错误，因为半径不可以小于0。当然可以在setRadius()方法中处理，处理的方法有很多种，比如说1.if语句判断，然后打印出错提示信息。2.try-catch语句解决异常。 当然可以这么解决。但如果构造方法中，紧紧跟着调用依赖于setRadius()的其它方法，那构造方法会接二连三地出错。为什么？因为被调用方法setRadius()在<strong>构造方法</strong>不知情的情况下中断了程序的正常运行。所以，setRadius()要做的事是，<strong>判断传入的参数是否符合要求，如果不符合，应该使用抛出异常告知调用方法，即构造方法，让构造方法去处理–继续抛出或者解决</strong>。<strong>当然，如果构造方法Exc()无法解决(同上所说)，就要继续抛出异常让main方法继续处理</strong></li><li><strong>什么时候使用try-catch</strong>？当处理不可意料的错误状况时应该使用。(尤其在网络环境的文件读写中，会出现断网，网络拒绝请求，请求文件不存在等不可预料的事件，这是程序员无法控制的)。<strong>不要用try-catch块处理简单的，可预料的情况</strong>。</li></ol></blockquote><p>如何理解要点的第四点呢？ <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">if</span>(setRadius() <span class="keyword">throws</span> IllegalArgumentException)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p><strong>假设第3点中，setRadius()抛出的异常可以在Exc()内部自己处理，不需要抛出异常给main方法</strong>，那这一段代码不需要try-catch，因为太简单了，可以预料。那执意要使用try-catch呢？虽然说try-catch使得错误处理的代码和正常的代码分离，更易懂。但是 &gt; 由于异常处理需要初始化新的异常对象，需要从调用栈返回，而且还需要沿着方法调用链来传播异常以便找到它的<strong>异常处理器</strong>，这个过程需要更多的内存和时间。</p><h3 id="异常的其他知识点">异常的其他知识点</h3><h4 id="异常方法的继承和重写">异常方法的继承和重写</h4><blockquote><p><strong>重写方法需要声明的异常和原方法声明的异常类型一致或不抛出</strong>。当一个类内的某方法没有声明异常时，不能在其子类的该方法重写声明异常。</p></blockquote><h4 id="链式异常的产生和抛出">链式异常的产生和抛出</h4><blockquote><p>和其他异常一起抛出一个异常，构成链式异常</p></blockquote><p>有时候我们需要在新异常的基础上，对原始异常进行信息附加，这样就可以产生一个 <em>链式异常</em></p><h4 id="链式异常的代码示例">链式异常的代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ee)&#123;</span><br><span class="line">            ee.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           method2();</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           <span class="comment">// 利用构造方法:Exception(String message, Throwable cause)</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"info from method"</span>,e);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"info from method2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果(行数和包名不一定一样)： &gt; java.lang.Exception: info from method at exc.Exc.method1(Exc.java:21) at exc.Exc.main(Exc.java:11) Caused by: java.lang.Exception: info from method2 at exc.Exc.method2(Exc.java:25) at exc.Exc.method1(Exc.java:18) … 1 more</p><p>从程序代码中可以看到，链式的异常主要是利用Excepion的构造方法，将导致的原因“Caused by…”作为参数传入，然后附加成新的异常再抛出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ee.printStackTrace();</span><br></pre></td></tr></table></figure><p>这段代码用来打印堆栈信息。可以查看错误的抛出时的“路径”，经过哪些方法，抛出错误的源头在哪里。这个方法对于编写程序员调试出现异常的程序十分有用。与Java运行时系统自身抛出的异常信息十分相似。</p><hr><h3 id="总结">总结</h3><blockquote><p>一个方法内部调用有抛出异常的方法时，或手动抛出异常时，必须做出处理。处理的方式有两种:1.继续向调用方法抛出异常 2.捕获异常并解决</p></blockquote><blockquote><p>main方法也可以不捕获并解决异常，直接抛出。这时是抛给Java运行时系统，异常信息会被打印并终止程序的运行。也就是我们一般见到的情况。</p></blockquote><div class="figure"><img src="http://old-image.geekaholic.cn/%E5%88%9B%E6%84%8F%20-%20Google%20%E6%90%9C%E7%B4%A2%281%29.jpg" alt="图片来自网络,侵删"><p class="caption">图片来自网络,侵删</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当一个语句在代码运行的时候可能会出错时(不可避免的错误，不为程序员在编写代码时可控制，比如文件不存在等)，我们应该如何处理？上一回讲到了&lt;a href=&quot;http://garcin-lam.github.io/2015/12/26/%E7%90%86%E6%B8%85Java%E5%BC%82%E5%B8%B8-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;异常的概念和分类&lt;/a&gt;，那我们来深入了解一下&lt;strong&gt;异常的处理&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;异常的处理&quot;&gt;异常的处理&lt;/h2&gt;
&lt;p&gt;在《理清Java异常(1)》中，我们简单地说了Java必检异常的处理方式。&lt;strong&gt;主要有两种处理(但解决异常的方法主要有一种，就是try-catch)&lt;/strong&gt;。怎么知道是必检异常？查看Java API文档中类的继承，除了Error和RunTimeException及它们子类，其他Exception类就是必检异常。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;声明和抛出异常&lt;/li&gt;
&lt;li&gt;try-catch块捕获异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，还要区别“处理”这个词的上下文或者说意境。其实说&lt;strong&gt;两种处理方式并不怎么准确，它可能会混淆视听&lt;/strong&gt;。(PS：好吧，当我咬文嚼字吧-.-!!)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当方法B调用会抛出异常的方法C，C出错抛出异常时，方法B使用try-catch捕获到异常，它有&lt;strong&gt;两种处理手段&lt;/strong&gt;，可以选择在catch语句块中&lt;strong&gt;继续抛出(throw)异常&lt;/strong&gt;(补充:’继续抛出’也可以不使用try-catch，直接声明异常即可)，让B的调用方法A用try-catch&lt;strong&gt;解决异常&lt;/strong&gt;，也可以在方法B的catch语句块中&lt;strong&gt;解决异常&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，异常只需要“解决”一次，当一个异常对象被捕获并被解决时，它会“消失”。但一个异常对象可以有两种“处理手段”，&lt;strong&gt;1.继续抛出&lt;/strong&gt;，&lt;strong&gt;2.解决异常&lt;/strong&gt;。
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Java" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Java/"/>
    
    
      <category term="Java" scheme="http://blog.geekaholic.cn/tags/Java/"/>
    
      <category term="马士兵" scheme="http://blog.geekaholic.cn/tags/%E9%A9%AC%E5%A3%AB%E5%85%B5/"/>
    
      <category term="异常处理" scheme="http://blog.geekaholic.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>理清Java异常(1)</title>
    <link href="http://blog.geekaholic.cn/2015/12/26/%E7%90%86%E6%B8%85Java%E5%BC%82%E5%B8%B8-1/"/>
    <id>http://blog.geekaholic.cn/2015/12/26/理清Java异常-1/</id>
    <published>2015-12-26T13:06:49.000Z</published>
    <updated>2019-09-26T05:21:46.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说fa在fa开lao头sao">说(fa)在(fa)开(lao)头(sao)</h3><p>为什么要写这篇博文？在完成Java面向对象程序设计的综合性实验过程中，使用到了文本IO和二进制IO。写过这部分代码的人都知道，IO难免会跟<code>异常</code>打交道。但在完成之后，却迷迷糊糊的，在需要处理异常的时候，总是按照IDE(使用的是<code>NetBeans</code>)的提示来处理异常，却不知道为什么要这样，为什么不要这样。很不喜欢这感觉，所以，就逮住这个机会来“更新”脑中的知识。哈哈，不知道我能将异常学到几成，又能清楚地说出几成。说得不对的地方，还希望看到这篇文章的人能够好心指出，谢谢~</p><p><strong>参考资料</strong> &gt; 1.<code>Java语言程序设计(基础篇)</code> 2.尚学堂马士兵的<code>Java视频教程</code></p><p><a id="more"></a></p><h3 id="异常的概念">异常的概念</h3><blockquote><p>异常是程序在运行时的错误。</p></blockquote><p>设计良好的程序应该在异常发生的时候提供处理这些错误的方法，使得程序不会因为异常的发生而阻断或者产生不可遇见的结果。</p><p>还有一个好处在于，程序员应该对可能抛出的异常进行处理，而不是让异常直接抛出给使用的用户，专业的异常术语可能导致用户不好的体验，所以应该进行处理，可以进行更加易懂或者说是友好的提示。</p><h3 id="异常的分类">异常的分类</h3><p>打开Java API的异常类，即<code>Throwable</code>类，可以看到有两个直接的子类(为什么是直接的子类？因为<strong>用户可以自定义自己的异常类</strong>)</p><ul><li>Throwable 所有异常类的根<ul><li><code>Error</code>(系统错误) <strong>不需要处理，也处理不了</strong>。描述的是内部系统的错误，由Java虚拟机抛出，很少会发生，一旦发生，只能通知用户以及尽量稳妥地终止程序。<ul><li>LinkageError</li><li>VirtualMatchineError</li><li>……</li></ul></li><li><p><code>Exception</code>(异常) <strong>错误或异常能被程序捕获和处理</strong>。描述的是程序和外部环境所引起的错误。</p><ul><li>ClassNotFoundException等 其他异常</li><li>RunTimeException(运行时异常) <strong>在Exception类中比较特殊的子类</strong>。描述的是程序设计错误，异常由Java虚拟机抛出。常见情况有:错误的类型转换，数组下标越界等。</li></ul></li></ul></li></ul><div class="figure"><img src="http://old-image.geekaholic.cn/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%A7%E6%A6%82%E5%88%86%E7%B1%BB.jpg" alt="异常的大概分类简单类图"><p class="caption">异常的大概分类简单类图</p></div><h4 id="为什么要这样分">为什么要这样分？</h4><p>在<code>Exception</code>中，为什么要特意说明<code>RunTimeException</code>？让我们来理清一下吧。 &gt; Error和Exception的子类–RunTimeException 以及它们的子类都称为<code>免检异常</code>，在程序中的任何一个地方都可能会出现，为避免过多使用try-catch块，不要求在代码中强制处理(<strong>有两种方式，try-catch块或者在方法头throws声明并在方法中抛出</strong>)。</p><p>前者Error是因为“系统出错，无法处理”的原因免检，而后者RunTimeException是因为在程序中的任何地方都可能出现，如果都处理，会增加许多代码(Error免检也有这个原因)，试想，如果每次数组访问或者算术运算都必须处理，那还不累死人？!所以，Java语言不强制要求编写代码<code>捕获</code>或<code>声明异常</code>。但其他异常则需要处理。</p><p><strong>总结</strong> &gt;- 异常是程序在运行时的错误 &gt;- Throwable是所有异常的父类。其有两个直接的子类–Error和Exception，其中Exception中有一个特殊的子类–RunTimeException，它和Error是<code>免检异常</code>，Java不强制要求处理免检异常。</p><div class="figure"><img src="http://old-image.geekaholic.cn/%E5%88%9B%E6%84%8F%20-%20Google%20%E6%90%9C%E7%B4%A2.jpg"></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;说fa在fa开lao头sao&quot;&gt;说(fa)在(fa)开(lao)头(sao)&lt;/h3&gt;
&lt;p&gt;为什么要写这篇博文？在完成Java面向对象程序设计的综合性实验过程中，使用到了文本IO和二进制IO。写过这部分代码的人都知道，IO难免会跟&lt;code&gt;异常&lt;/code&gt;打交道。但在完成之后，却迷迷糊糊的，在需要处理异常的时候，总是按照IDE(使用的是&lt;code&gt;NetBeans&lt;/code&gt;)的提示来处理异常，却不知道为什么要这样，为什么不要这样。很不喜欢这感觉，所以，就逮住这个机会来“更新”脑中的知识。哈哈，不知道我能将异常学到几成，又能清楚地说出几成。说得不对的地方，还希望看到这篇文章的人能够好心指出，谢谢~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt; &amp;gt; 1.&lt;code&gt;Java语言程序设计(基础篇)&lt;/code&gt; 2.尚学堂马士兵的&lt;code&gt;Java视频教程&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="编执狂" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/"/>
    
      <category term="Java" scheme="http://blog.geekaholic.cn/categories/%E7%BC%96%E6%89%A7%E7%8B%82/Java/"/>
    
    
      <category term="Java" scheme="http://blog.geekaholic.cn/tags/Java/"/>
    
      <category term="马士兵" scheme="http://blog.geekaholic.cn/tags/%E9%A9%AC%E5%A3%AB%E5%85%B5/"/>
    
      <category term="异常处理" scheme="http://blog.geekaholic.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
